function Stim =  vcarrierori(pars,myscreen)% Stim =  vcarrierori(pars,myscreen)%% code for vcarrierori.x%% derived from vis2luts2grats100%% MC and AB 2004%% SEE CODE AT THE END OF THE FUNCTION TO TEST % pars = [ 100 2 20 50 0 50 3 ]% ------------- read the parameters of counterphase gratingdur 	= pars(1)/10;       % s, durationnperiods = pars(2);       % s, period of change in orientationtf      = pars(3)/10;       % Hz, temp freq of grating sf      = pars(4)/100;      % cpd, spat freq of gratingphase   = pars(5)*(pi/180); % radians, phase of grating c       = pars(6)/100;      % percent contrast noris   = pars(7);          % number of orientationsif nperiods<0	reverseflag = 1;	nperiods = -nperiods;else	reverseflag = 0;endrad = myscreen.Ymax/2; SinPars = [];SinPars.tFreq	 			= tf; 	SinPars.SpatialFrequency  	= sf; 		SinPars.phase  				= phase; 		SinPars.Contrast 	 		= c; SinPars.innerRad			= 0; SinPars.outerRad			= rad;SinPars.sqwv	            = 0;	% 0=sine, 1=squarectr.x	 			        = 0; ctr.y				        = 0; % total number of framesnframestotal    = round(myscreen.FrameRate * dur);nframesperiod	= round(nframestotal/ nperiods);% vector of number of frames for each orientationnframesperori = linspace(0,nframesperiod,noris+1);nframesperori = diff(round(nframesperori));% vector of orientationsoris = linspace(0,2*pi,noris+1);oris = oris(1:noris);if reverseflag	oris = oris(end:-1:1);end%-------------- create the stim structure --------------Stim = [];[Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');% turn the 3-D array into a cell array:luts = cell(nCluts,1);for iClut = 1:nCluts	luts{iClut} = squeeze(Cluts(iClut,:,:)); endStim.luts = luts;for iori = 1:noris	fprintf(1,'.')	SinPars.Orientation = oris(iori); 	Stim.frames{1}{iori} = ltMakeGratingFrame(SinPars,myscreen,'reserve3'); % is iori in the right place?endStim = ltMakeOffScreenWindows(myscreen,Stim,0); % put the flag to 1 if you are debuggingStim.sequence.luts = mod([1:nframesperiod]-1,nCluts) + 1;Stim.sequence.frames 	= ones(1,nframesperiod); % for allocation and initializationiframe = 0;for iori = 1:noris	Stim.sequence.frames(iframe+[1:nframesperori(iori)]) = iori;	iframe = iframe+nframesperori(iori);end%------- define position rectx1 = (round(myscreen.Xmax/2) - SinPars.outerRad);y1 = (round(myscreen.Ymax/2) - SinPars.outerRad);x2 = (round(myscreen.Xmax/2) + SinPars.outerRad);y2 = (round(myscreen.Ymax/2) + SinPars.outerRad);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim.nperiods = nperiods;return%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 65;ltLoadCalibration(myscreen,3);Stim = vcarrierori([ 200 -4 20 20 0 50 3 ],myscreen);vsPlayStimulus(myscreen,Stim,'norush');	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');