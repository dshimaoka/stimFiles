function Stim = oglKalatsky(pars,myscreen)% KALATSKY code for oglKalatsky.x% % Stim =  kalatsky(pars,myscreen)% Computes stimulus based on Kalatsky & Stryker, Neuron, 2003%   STIM = KALATSKY(PARS, MYSCREEN) returns stimulus structure, given%   stimulus parameters PARS and screen parameter MYSCREEN%   PARS = [ dur tf sf c ori flickerfreq duty ]%%   If flickerfreq = 0 the original kalatsky stimulus is generated (square%   wave grating with contrast c)%   If flickerfreq > 0 the background is set to gray and the moving bar%   flickers at flickerfreq with contrast c%%   Kalatsky's original parameters:%   tf 0.1-0.2 cycles/sec%   sf 0.01-0.02 cycles/deg%   tph, sph 0?%   c 100%   ori 0 / 90 / 180 / 270%   flickfreq 0%   duty low%%   uses "aperture" trick (see DriftDemo2.m)%   LB 06-26-07%   LB 07-05-07 change tfreq = pars(2)/1000, sfreq = pars(3)/1000%   LB 07-10-19 added new field globalAlpha for use with the new version of vsPlayStimulus%   LB 08-01-22 changed Stim.ori to be a vector of size nframes instead of a scalar to be compatible with a new usage in vsPlayStimulus%   LB 08-01-23 changed Stim.srcRect to be a cell to be compatible with a new usage in vsPlayStimulus%   LB 08-01-28 changed Stim.position to be matrix of size nframes x 4%   LB 08-02-22 changed name to oglKalatsky% Parse the input parametersdur                     = pars(1)/10; % duration in ssinpars.tfreq           = pars(2)/1000; % temporal freq cyc/s	sinpars.sfreq           = pars(3)/1000; % spatial freq cyc/deg		sinpars.tempphase       = 0; 		sinpars.spatphase       = 0; 		sinpars.contrast        = pars(4)/100; sinpars.orientation 	= 0; % supplied ori (pars(5)) is used in vsPlayStimulus to rotate the 0 deg stimulussinpars.dima			= ceil(sqrt(myscreen.Xmax^2 + myscreen.Ymax^2)); % max size: screen diagonalsinpars.dimb			= sinpars.dima;sinpars.x               = ltdeg2pix(0,myscreen); % Centre xsinpars.y               = ltdeg2pix(0,myscreen); % Centre ysinpars.flickerfreq		= pars(6)/10; % frequency of flicker sinpars.duty            = pars(7)/100; % duty cycle 0:1 (0.5 is equal B/W, 1 is pure white) nframes = round(myscreen.FrameRate * dur);% half the size of the aperturetexsize = 0.5*sinpars.dima;% Spatial frequency in cycles/pixelPixPerCycle = ltdeg2pix(1/sinpars.sfreq,myscreen);sinpars.frequency = 1/PixPerCycle; % sf in cycles/pixPixPerCycle=ceil(PixPerCycle);  % pixels/cyclevisiblesize=2*texsize+1;% Create one single static grating image: grid of x and y[x,y]=meshgrid(-texsize:texsize + PixPerCycle, -texsize:texsize);    % the gratingangfreq = 2*pi* sinpars.frequency * (...     cos(sinpars.orientation).*x + ...     sin(sinpars.orientation).*y ) + sinpars.spatphase;% duty cyclespatialstim = mod(angfreq, 2*pi) <= 2*pi*sinpars.duty;grat = {2*sinpars.contrast * spatialstim - 1}; %scale to -1:1if sinpars.flickerfreq > 0    grat{1}(grat{1} < 0) = 0; % set "background" to 0    Stim.frames{1}{1} = uint8( grat{1}*126 + 129 ); % make one frame with white bars    Stim.frames{1}{2} = uint8( grat{1}*-1*126 + 129 ); % make one frame with black barselse    Stim.frames{1}{1} = uint8( grat{1}*126 + 129 );end% Query duration of monitor refresh interval:ifi=Screen('GetFlipInterval', myscreen.windowPtr);waitframes = 1;waitduration = waitframes * ifi;% Translate requested speed of the grating (in cycles per second)% into a shift value in "pixels per frame", assuming given% waitduration: This is the amount of pixels to shift our "aperture" at% each redraw:shiftperframe= sinpars.tfreq * PixPerCycle * waitduration;for iframe = 1 : nframes    xoffset = mod(iframe*shiftperframe,PixPerCycle);    Stim.srcRect{iframe} =[xoffset 0 xoffset + visiblesize visiblesize];end% Make the lookup tableStim.luts{1} = repmat([128 255 0 1:253]',1,3);% Make sequenceif sinpars.flickerfreq > 0    nFramesPerHalfCycle = round((myscreen.FrameRate * 1/sinpars.flickerfreq)/2); % number of frames per flicker cycle    Stim.sequence.frames = [ones(1, nFramesPerHalfCycle) ones(1,nFramesPerHalfCycle)+1]; % alternate between frame 1 and 2    Stim.sequence.frames = repmat(Stim.sequence.frames, 1, fix(nframes/(nFramesPerHalfCycle*2)));    if mod(nframes,nFramesPerHalfCycle*2) > 0 % append first few frames if there are any left        Stim.sequence.frames = [Stim.sequence.frames Stim.sequence.frames(1:mod(nframes,nFramesPerHalfCycle*2))];    endelse    Stim.sequence.frames = ones(1,nframes);endStim.sequence.luts = ones(1,nframes);fprintf(1,'done\n');% Definition of the drawn rectangle on the screen:dstRect=[0 0 visiblesize visiblesize];dstRect=CenterRect(dstRect, myscreen.ScreenRect);% The position vectorfor iframe = 1 : nframes    Stim.position(iframe,:) = dstRect;endStim.ori = pars(5)*ones(1,nframes);Stim.nperiods = 1;Stim.globalAlpha = ones(1,nframes);	return%--------------------------------------------------------------------------------------------% TO TEST IT:%   Kalatsky's original parameters:%   tf 0.1-0.2 cycles/sec%   sf 0.01-0.02 cycles/deg%   tph, sph 0?%   c 100%   ori 0 / 90 / 180 / 270%   flickfreq 0%   duty lowwhichScreen = 1;myscreen = ltScreenInitialize(whichScreen);myscreen.Dist = 57;Stim = [];dur = 400;tf = 120; % tf = tf/1000sf = 20; % sf = sf/1000c = 100;ori = 180;flickerfreq = 30;duty = 10;pars = [ dur tf sf c ori flickerfreq duty ];if ~isempty(Stim)    ltClearStimulus(Stim,'nowarnings'); endStim = kalatsky(pars,myscreen);Stim = vsLoadTextures(myscreen, Stim);vsPlayStimulus(myscreen,Stim);		ltClearStimulus(Stim,'nowarnings'); Screen('CloseAll');