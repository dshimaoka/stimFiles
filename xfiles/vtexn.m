function [Stim,noise] =  vtexn(pars,myscreen)% Stim =  vsquaretexn(pars,myscreen)%% % SEE CODE AT THE END OF THE FUNCTION TO TEST % TexPars = [];dur 	= pars(1)/10 ; %= dur; % Stim. durationTexPars.x	=  round(ltdeg2pix(pars (2)/10,myscreen)); % Centre x (deg*10).TexPars.y	=  round(ltdeg2pix(pars( 3)/10,myscreen)); % Centre y (deg*10).TexPars.nfr = pars(4); % repaint every nfr frameTexPars.ufr = pars(5); % every ufr repaint is uniqueTexPars.ntex = pars(6); % number of tex elementsTexPars.nGrays = pars(7); % number of graz levelsTexPars.innerRad =  ceil(ltdeg2pix(pars(8)/10,myscreen)/2); % inner diameter (deg*10).TexPars.outerRad = floor(ltdeg2pix(pars(9)/10,myscreen)/2); % outer diameter (deg*10).TexPars.order = pars(10); % order of moment to vary (0,1,2,3,4,5)TexPars.moddepth = pars(11)/100; % modulation depth of deviations from uniform distr (0 to 100%).TexPars.statetex = pars(12); % seed of random sequence underlying texture generationdurframes = round(myscreen.FrameRate * dur); % stim duration in framesnrepaints = ceil(durframes / TexPars.nfr); % number of stim repaintsntexframes = ceil(nrepaints/ TexPars.ufr); % number of tex stim%%%%%%%%%%%%%%% make texturesrescf= makeBasisFunctions(TexPars.nGrays);rand('state',TexPars.statetex);    magnitude=TexPars.moddepth;	lowerbound = 3;upperbound = 255;% ntexels = ceil(TexPars.outerRad * 2 / TexPars.texelsize);TexPars.texelsize = ceil(TexPars.outerRad * 2 / TexPars.ntex);so = [TexPars.ntex,TexPars.ntex];sn = so*TexPars.texelsize;sc = so./sn + eps; % actual scaling between images, eps is needed% circular window. image size always even because specified by radius.xx = round([0:sn(1)-1]-sn(1)/2);[XX,YY]=meshgrid(xx,xx);ZZ2 = XX.^2+YY.^2;sel= find( ZZ2 > TexPars.outerRad.^2 | ZZ2 < TexPars.innerRad.^2);for iframe = 1:ntexframes	% pdf is sum uniform distribution with a basis function	% f(x) = P{X==x}	density = rescf(:,1) + magnitude*rescf(:,TexPars.order+1);    % [0,delta,1]    noise{iframe} = (randpdf(density,TexPars.ntex,TexPars.ntex)-1)/(TexPars.nGrays-1);    % rescale    intensities = round(noise{iframe}*(upperbound-lowerbound))+lowerbound;	% upsample to obtain image with desired texel size.	tempframe =  intensities(floor(sc(1)/2:sc(1):end)+1,floor(sc(2)/2:sc(2):end)+1,:);	if any(size(XX)~=size(tempframe));		disp('texture array size does not match that of aperture');	end    	tempframe(sel)=0; % background is gray    Stim.frames{1}{iframe} = uint8(tempframe);end%%%%%%%%%%%%%%% make the lutStim= ltMakeOffScreenWindows(myscreen,Stim,1);nreslutentries = 3;ilut = 1;Stim.luts{ilut} = zeros(256,3);Stim.luts{ilut}(1,1:3) = 128;Stim.luts{ilut}(2,1:3) = 255;Stim.luts{ilut}(3,1:3) = 0;Stim.luts{ilut}(4:256,1:3) = repmat(round([0:256/(256-nreslutentries):255])',1,3);%%%%%%%%%%%%%%%%%% generate unique frames sequenceuframeseq =  mod(floor(rand(1,nrepaints)*ntexframes),ntexframes)+1;% upsample frame sequence according to refresh rateso = size(uframeseq);sn = so*TexPars.nfr;sc = so./sn + eps;% actual scaling between images, eps is neededframeseq =  uframeseq(floor(sc(1)/2:sc(1):end)+1);% discard additional framesStim.sequence.frames = frameseq(1:durframes);nCluts = length(Stim.luts);Stim.sequence.luts 		= mod([0:durframes-1],nCluts) +1;%------- define position rect[nx,ny]=size(Stim.frames{1}{1});x1 = (round(myscreen.Xmax/2) - nx/2);y1 = (round(myscreen.Ymax/2) - nx/2);x2 = (round(myscreen.Xmax/2) + nx/2);y2 = (round(myscreen.Ymax/2) + nx/2);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],TexPars.x,TexPars.y);% The number of times you want to see the movie		Stim.nperiods = 1;return%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function out = randpdf(frequencies,m,n);% out = randpdf(frequencies,m,n);% frequencies is the discrete pdf. must sum to one.if round(sum(frequencies)*1e4)/1e4 ~=1 	str = sprintf('frequencies sum to %2.3f',sum(frequencies));    error(str);endncategories = length(frequencies);pmax = max(frequencies); ratios = inf*ones(size(frequencies));sel = find(frequencies);ratios(sel) = pmax./frequencies(sel);numbers = [];ndraws = 1024;while length(numbers)<m*n	urand = ceil(rand(1,ndraws)*ncategories);	test = ratios(urand).*rand(1,ndraws)';	samples = find(test<1);	numbers = [numbers urand(samples)];end% fprintf(1,'Generated %i numbers. Output: %i.\n ',length(numbers),(m*n));out = reshape(numbers(1:m*n),m,n);return;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function rescf= makeBasisFunctions(ngrays)% rescf= make_orthogonal_basis_functions(ngrays)nbasisfunctions =7;% make nonorthogonal basisv = [0:ngrays-1]';f = [];for i = 1 : nbasisfunctions;    f(1:ngrays,i)=v.^(i-1);end% orthogonalizeorthf = gram_schmidt(f);% normalized each basis function to 1;ulevel = 1/ngrays;for i =1:nbasisfunctions    mlevel(i) = max(abs(orthf(:,i)));    rescf(:,i) = orthf(:,i)/abs(mlevel(i))*ulevel;endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function Qhat = gram_schmidt(a);%   gram_schmidt   -  script implementing the step-by-step%               Gram-Schmidt algorithm.%%[ rowsA, colsA ] = size(a) ;%Qhat = a(:,1)/norm(a(:,1)); %for j = 2:colsA  Qhat(:,j) = a(:,j) - Qhat*(Qhat'*a(:,j)) ;  Qhat(:,j) = Qhat(:,j)/norm( Qhat(:,j) );endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:SCREEN('CloseAll');iscreen = 0;myscreen = ltScreenInitialize(iscreen);		myscreen.Dist = 57;% pars:= [ dur x y nfr ufr ntex ngrays idiam2 odiam2 order moddepth seed]pars =   [ 50  0 0  1   1  40     16     0      100    2    -100   99];[Stim,noise] = vtexn(pars,myscreen);vsPlayStimulus(myscreen,Stim);SCREEN('CloseAll');