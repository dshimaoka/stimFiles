function Stim =  v2luts1grat1noise(pars,myscreen)% Stim =  v2luts1grat1tex(pars,myscreen)%% SEE CODE AT THE END OF THE FUNCTION TO TEST % ------ parse the pars (excuse the pun)SinPars = [];dur 	= pars(1)/10 ; %= dur; % Stim. durationctr.x	 			=  round(ltdeg2pix(pars (2)/10,myscreen)); % Centre x (deg*10).ctr.y				=  round(ltdeg2pix(pars( 3)/10,myscreen)); % Centre y (deg*10).SinPars.tFreq	 			= pars(4)/10 * 2; 	% 2x factor since presented every other framesSinPars.SpatialFrequency  	= pars(5)/100; 		SinPars.phase  				= pars(6)* (pi/180); 		SinPars.Contrast 	 		= pars(7)/100 * 2; % 2x factor since presented every other framesSinPars.Orientation 		= pars(8) * (pi/180); SinPars.innerRad			=  ceil(ltdeg2pix(pars( 9)/10,myscreen)/2); % inner diameter (deg*10).SinPars.outerRad			= floor(ltdeg2pix(pars(10)/10,myscreen)/2); % outer diameter (deg*10).SinPars.sqwv	= 0;	% 0=sine, 1=squareNoisePars = [];NoisePars.x = ctr.x;NoisePars.y = ctr.y;NoisePars.tFreq = pars(11) / 10 * 2; % modulation frequency (Hz*10), 2x factor since presented every other framesNoisePars.innerRad =  ceil(ltdeg2pix(pars(12)/10,myscreen)/2); % inner diameter (deg*10).NoisePars.outerRad = floor(ltdeg2pix(pars(13)/10,myscreen)/2); % outer diameter (deg*10).NoisePars.alpha = min(0,pars(14)/10); % spectrum has f^alpha form. alpha <= 0.NoisePars.modDepth = pars(15)/100; % modulation depth of deviations from uniform distr (0 to 100%).NoisePars.phaseSeed = pars(16)/100;% seed of phase noise%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% no maskif NoisePars.outerRad == 0 | NoisePars.modDepth==0	Stim = cell(1,1);	nframes = round(myscreen.FrameRate * dur);	SinPars.tFreq = SinPars.tFreq /2;	SinPars.Contrast = SinPars.Contrast /2;else 	Stim = cell(2,1);	nframes = round(myscreen.FrameRate * dur / 2);end%%%%%%%%%%%%%%% test gratingipatch = 1;Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars,myscreen,'reserve3');Stim{ipatch}= ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);[Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');Stim{ipatch}.luts = cell(nCluts,1); % allocationfor iClut = 1:nCluts	Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); endStim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initializationStim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation onlyfor iframe = 0:nframes - 1 % initialization	Stim{ipatch}.sequence.luts(iframe+1) = mod(iframe,nCluts) + 1;end%------- define position rectx1 = (round(myscreen.Xmax/2) - SinPars.outerRad);y1 = (round(myscreen.Ymax/2) - SinPars.outerRad);x2 = (round(myscreen.Xmax/2) + SinPars.outerRad);y2 = (round(myscreen.Ymax/2) + SinPars.outerRad);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim{ipatch}.nperiods = 1;%%%%%%%%%%%%%% mask noiseif  NoisePars.outerRad == 0 | NoisePars.modDepth==0	Stim = Stim{ipatch};	return;end;ipatch =2;frames ={};% use new random generator. use seed from parameter.rand('state',NoisePars.phaseSeed);frames{1}{1}=makeNoiseFrame(NoisePars);Stim{ipatch}.frames=frames;Stim{ipatch}= ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);Stim{ipatch}.luts = makeNoiseClut(NoisePars,myscreen);Stim{ipatch}.sequence.frames = ones(1,nframes); % for allocation and initializationnCluts = length(Stim{ipatch}.luts);Stim{ipatch}.sequence.luts 		= mod([0:nframes-1],nCluts) +1;%------- define position rect[nx,ny]=size(Stim{2}.frames{1}{1});x1 = (round(myscreen.Xmax/2) - nx/2);y1 = (round(myscreen.Ymax/2) - nx/2);x2 = (round(myscreen.Xmax/2) + nx/2);y2 = (round(myscreen.Ymax/2) + nx/2);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);% The number of times you want to see the movie		Stim{ipatch}.nperiods = 1;returnfunction [luts,actualTFreq] = makeNoiseClut(NoisePars,myscreen)nCluts=round(myscreen.FrameRate/NoisePars.tFreq);	% number of frames per cycleactualTFreq=myscreen.FrameRate/nCluts; % calculate actual temporal freq (Hz)luts = {};% range 0-252 gives 253 entries.% 3 additional lut entries reserved for gray, black and white.nreslutentries = 3;depth = max(0.0,min(1.0,NoisePars.modDepth));for ilut = 1:nCluts		luts{ilut} = zeros(256,3);	luts{ilut}(1,1:3) = 128;	luts{ilut}(2,1:3) = 255;	luts{ilut}(3,1:3) = 0;	magnitude = depth*sin((ilut-1)/nCluts*2*pi);		lb = (.5-magnitude/2)*255;	ub = (.5+magnitude/2)*255;	luts{ilut}(4:256,1:3)=repmat(round(linspace(lb,ub,253))',1,3);end % for ilutreturn;function imframe = makeNoiseFrame(NoisePars)npix = 2*NoisePars.outerRad+1; % must be oddxx= linspace(-1,1,npix);[xxx,yyy]=meshgrid(xx,xx);freqs = sqrt(xxx.^2+yyy.^2);amps = ifftshift(freqs.^NoisePars.alpha);amps(1,1)=0; % zeros dc;phases = angle(fft2(rand(npix))); % extract phase from random noisespectra = amps.*exp(j*phases);ourimage = real(ifft2(spectra));minval = min(ourimage(:));maxval = max(ourimage(:));normimage = (ourimage-minval)/(maxval-minval);lowerbound = 3;upperbound = 255;frame = floor(normimage*((upperbound-lowerbound)+1))+lowerbound;sel = find(freqs>1 | freqs<NoisePars.innerRad/NoisePars.outerRad);frame(sel)=0; % background is gray% imagesc(real(frame));colormap gray;axis square;imframe = uint8(frame);return%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);% pars:= [ dur x y tf1 sf1 ph1	c1 ori1 idiam1 odiam1  tfn idiam2 odiam2 alpha mod seed]Stim1 = v2luts1grat1noise([ 40 0 0 10 10 0 50   0  0 40    10 40 100 -13 50 0],myscreen);vsPlayStimulus(myscreen,Stim1);Stim2 = v2luts1grat1noise([ 40 0 0 20 10 0 50   0  0 40      20 40 200 -15 100 0],myscreen);vsPlayStimulus(myscreen,Stim2);ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');