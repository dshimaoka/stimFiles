function Stim =  vstatgrat(pars,myscreen);% Stim =  vstatgrat(pars,myscreen);%% Stim = vstatgrat([dur sf100 c ori phase x y diam ton toff], myscreen)%% to see something reasonable, try with pars = [30 100 50 30 0 0 0 60 10 10]%% 2004-09 MC and RF% ------ parse the parsxpars.dur 	= pars(1)/10;  % = dur; % Stim. duration.xpars.sf 	= pars(2)/100;  % = sf100; % Spatial frequency.xpars.c 	= pars(3)/100; % = c; % Stim. constrast. xpars.ori 	= pars(4)* pi/180; % = ori; % Stim. orientation .xpars.phase = pars(5)* pi/180; % phasexpars.x		= ceil(ltdeg2pix(pars(6)/10,myscreen)); % Center x (deg/10).xpars.y		= ceil(ltdeg2pix(pars(7)/10,myscreen)); % Center y (deg/10).xpars.diam	= ceil(ltdeg2pix(pars(8)/10,myscreen)); % diameter (deg/10).xpars.ton   = pars( 9)/10; % time onxpars.toff  = pars(10)/10; % time off% ------ convert them into relevant fields in SinParsSinPars.width 			 = xpars.diam; SinPars.height			 = xpars.diam;SinPars.Contrast		 = xpars.c;SinPars.Orientation 	 = xpars.ori;	% radiansSinPars.SpatialFrequency = xpars.sf;	% Cycles/degreeSinPars.outerRad 		 = round(xpars.diam/2); % pixels!SinPars.phase			 = xpars.phase;	% 0 is cosine phase, must be RADIANS% ------ other SinPars fields to be setSinPars.sqwv		= 0;	% 0=sine, 1=squareSinPars.innerRad 	= 0;	% pixels!SinPars.tFreq		= 1;	% Hz % pretend it drifts. We'll only use the first clut% ------ other xpars to be keptctr.x = xpars.x;ctr.y = xpars.y;nframes = round(myscreen.FrameRate * xpars.dur);nframes_pre  = round(myscreen.FrameRate * xpars.ton);nframes_post = round(myscreen.FrameRate * xpars.toff);if nframes_pre > nframes | nframes_pre+nframes_post > nframes	nframes_pre = 0;	nframes_post = 0;	nframes = 1;	warning('Problem! Ton and/or Toff are inconsistent with dur');endnframes_stim = nframes - nframes_pre - nframes_post;% ------ that's it, no more use for xparsclear xpars%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim.frames{1}{1} = ltMakeGratingFrame(SinPars,myscreen,'reserve3');Stim = ltMakeOffScreenWindows(myscreen,Stim,1);[Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');offClut=128*ones(256,3);offClut(2,:) = 255;offClut(3,:) = 1;Stim.luts{1} = offClut;Stim.luts{2} = squeeze(Cluts(1,:,:));Stim.sequence.frames 	= ones(1,nframes);Stim.sequence.luts 		= ones(1,nframes); for iframe = nframes_pre+[1:nframes_stim]	Stim.sequence.luts(iframe) = 2;end%------- define position rectx1 = (round(myscreen.Xmax/2) - round(SinPars.width/2));y1 = (round(myscreen.Ymax/2) - round(SinPars.height/2));x2 = (round(myscreen.Xmax/2) + round(SinPars.width/2));y2 = (round(myscreen.Ymax/2) + round(SinPars.height/2));	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim.nperiods = 1;return%----------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);dur = 30;sf100 = 50;c = 50;ori = 45;phase = 0;x = 100;y = 0;diam = 60;ton = 10;toff = 10;Stim = vstatgrat([dur sf100 c ori phase x y diam ton toff],myscreen);vsPlayStimulus(myscreen,Stim,'norush');	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');	