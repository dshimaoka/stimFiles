function oglStim = oglTwoSequenceGratings(pars,myscreen,flagNoTextures)% Two gratings, drifting or flickering, in disks or annuli or rectangles%% oglStim =  oglTwoGratings(pars,myscreen)% where pars is% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb2 x2 y2 flick2 sqwv2 duty2 shape2 ]%% sqwv = 1 for square waves, 0 for sin waves% duty is the duty cycle in percent (normal is 100)% shape = 0 for annulus, 1 for rectangle% dima, dimb are inner and outer diameters (for annuli) or dimensions x and y (for rectangles)%% oglStim = oglTwoGratings(pars,myscreen,flagNoTextures) lets you specify% whether you don't want textures (DEFAULT: flagNoTextures = false).%% History:% vmovie2gratinterok.x (old fashioned interleaved stimulus)% oglMovie2Grat.x (OpenGL version needing lots of textures)% oglMovie2GratLin.x (with alpha blending but bug in drifting gratings)% oglTwoGratings (this file): fixed bug, done away with fake interleaving%% MC 2010-02-05 started it (not functional yet)% DS 2015-7-10 from oglTwoGratings%% dummies for debugging% pars = [ 20 ...%     30 5 0 0 100 80 0 200 0 0 0 0 100 0 ...%     30 5 0 0   0 80 0 200 0 0 0 0 100 0 ];%% myscreen = ltScreenInitialize;%% parse the parametersif nargin < 3    flagNoTextures = false;enddur 	= pars(1)/10; % s, durationStTE    = pars(2)/10;%early stim start timeEnTE    = pars(3)/10;%ealy stim end timeStTL    = pars(4)/10;%late stim start timeEnTL    = pars(5)/10;%late stim end timeduty  		= pars(6)/100;    ipar = 6;sinpars = [struct; struct];for igrat = 1:2    sinpars(igrat).tfreq	 	= pars(ipar+1)/10;              % Hz    sinpars(igrat).sfreq  		= pars(ipar+2)/100;             % cpd    sinpars(igrat).tempphase  	= pars(ipar+3) * (pi/180);      % radians    sinpars(igrat).spatphase  	= pars(ipar+4) * (pi/180);      % radians    sinpars(igrat).contrastE 	= pars(ipar+5)/100;             % percent    sinpars(igrat).contrastL 	= pars(ipar+6)/100;             % percent    sinpars(igrat).orientation 	= pars(ipar+7);                 % deg    sinpars(igrat).dima			= ceil(myscreen.Deg2Pix(pars(ipar+8)/10)); %ceil (ltdeg2pix(pars(ipar+8)/10,myscreen)); % deg    sinpars(igrat).dimb			= floor(myscreen.Deg2Pix(pars(ipar+9)/10)); %floor(ltdeg2pix(pars(ipar+9)/10,myscreen)); % deg    %sinpars(igrat).x	 		= ltdeg2pix(pars(ipar+10)/10,myscreen); % deg    %sinpars(igrat).y		 	= ltdeg2pix(pars(ipar+11)/10,myscreen); % deg    [sinpars(igrat).x, sinpars(igrat).y] = myscreen.Deg2PixCoord(pars(ipar+10)/10, pars(ipar+11)/10);    %sinpars(igrat).flicker 		= pars(ipar+11);    sinpars(igrat).shape  		= pars(ipar+12); % 0 = circle; 1 = rect    ipar = 18;endnframes = round(myscreen.FrameRate * dur);%modified from vmovie3sequentialGrating.mfrmSwitchStTE = round(myscreen.FrameRate * StTE);frmSwitchEnTE = round(myscreen.FrameRate * EnTE);frmSwitchStTL = round(myscreen.FrameRate * StTL);frmSwitchEnTL = round(myscreen.FrameRate * EnTL);% make sure the switch frames are reasonablefrmSwitchStTE = max(frmSwitchStTE,1);frmSwitchEnTE = max(frmSwitchEnTE,1);frmSwitchStTE = min(frmSwitchStTE,nframes);frmSwitchEnTE = min(frmSwitchEnTE,nframes);frmSwitchEnTE = max(frmSwitchEnTE, frmSwitchStTE);frmSwitchStTL = max(frmSwitchStTL,1);frmSwitchEnTL = max(frmSwitchEnTL,1);frmSwitchStTL = min(frmSwitchStTL,nframes);frmSwitchEnTL = min(frmSwitchEnTL,nframes);frmSwitchEnTL = max(frmSwitchEnTL, frmSwitchStTL);%timecourse of contrast    contrastTimeCourse = zeros(2, nframes);for igrat = 1:2    contrastTimeCourse(igrat, 1:frmSwitchStTE-1) = 0;     contrastTimeCourse(igrat, frmSwitchStTE:frmSwitchEnTE-1) = sinpars(igrat).contrastE;     contrastTimeCourse(igrat, frmSwitchEnTE:frmSwitchStTL-1) = 0;     contrastTimeCourse(igrat, frmSwitchStTL:frmSwitchEnTL-1) = sinpars(igrat).contrastL;     contrastTimeCourse(igrat, frmSwitchEnTL:end) = 0; end%% Fundamental fieldsoglStim = oglStimNew(); % preallocate so you have correct order of parametersoglStim.Generation = 3; % 3rd gen (1 = pre-OpenGL, 2 = partial OpenGL, 3 = fuller OpenGL)oglStim.Type = 'oglTwoGratings';oglStim.Pars = pars;oglStim.FlagMinusOneToOne = true;oglStim.TextureParameters = setdiff((1:length(pars)),[6 7 10 11 20 21 24 25]);%% Define fields ori, globalAlpha, and positionoglStim.ori = [sinpars(:).orientation]'*ones(1,nframes);oglStim.globalAlpha = contrastTimeCourse/2; %[sinpars(:).contrast]'*ones(1,nframes) /2;% notice division by two otherwise it does not work...oglStim.position = zeros(2,4);for igrat = 1:2    switch sinpars(igrat).shape        case 0            % it is an annulus            maxrad = max(sinpars(igrat).dima/2, sinpars(igrat).dimb/2);            nx = ceil(4*maxrad);            ny = ceil(4*maxrad);        case 1            % it is a rectangle            nx = max(1,sinpars(igrat).dima);            ny = max(1,sinpars(igrat).dimb);    end        % The position vector%     x = round(sinpars(igrat).x + myscreen.Xmax/2 - nx/2);%     y = round(sinpars(igrat).y + myscreen.Ymax/2 - ny/2);    x = round(sinpars(igrat).x - nx/2);    y = round(sinpars(igrat).y - ny/2);    oglStim.position(igrat,:) = [x y x+nx y+ny];endif flagNoTextures    returnend%% Define Frames and FrameSequence for each component gratingFrames          = cell(2,1);FrameSequence   = cell(2,1);for igrat = 1:2        t = 0.001; % threshold    if duty<1        beta = log(t)/log(cos( duty*pi/2 ));    else        beta = 1;    end        % Spatial frequency in cycles/pixel    PixPerCycle = myscreen.Deg2Pix(1/sinpars(igrat).sfreq);%ltdeg2pix(1/sinpars(igrat).sfreq,myscreen);    sinpars(igrat).frequency = 1/PixPerCycle; % sf in cycles/pix        nx = diff(oglStim.position(igrat,[1 3]));    ny = diff(oglStim.position(igrat,[2 4]));            % Make a grid of x and y%     switch sinpars(igrat).shape%         case 0%             [xx,yy] = meshgrid(1-nx:nx,1-ny:ny);%         case 1%             [xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);%     end          [xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);      % Image of the spatial phase of the stimulus (in radians)    AngFreqs = -2*pi* sinpars(igrat).frequency * xx + sinpars(igrat).spatphase;        switch sinpars(igrat).shape        case 0            % an annulus            %             dd = sqrt(xx.^2+yy.^2);            %             WindowImage = double(dd >= sinpars(igrat).dima/2 & dd <= sinpars(igrat).dimb/2);            sigx = sinpars(igrat).dima/2 / sqrt((2*log(2)));            sigy = sinpars(igrat).dimb/2 / sqrt((2*log(2)));            WindowImage = exp(-(xx.^2/(2*sigx^2) + yy.^2/(2*sigy^2)));        case 1            % a rectangle            WindowImage = double(ones(size(xx)));    end        % The temporal phase of the response        nFramesInPeriod = round(myscreen.FrameRate / sinpars(igrat).tfreq);    TemporalPhase = 2*pi*(0:(nFramesInPeriod-1))/nFramesInPeriod + sinpars(igrat).tempphase;        ActualFrequency = myscreen.FrameRate/nFramesInPeriod;    if abs(ActualFrequency/sinpars(igrat).tfreq-1)>0.1        fprintf(1,'Frequency %d is %2.2f rather than %2.0f Hz\n', ...            igrat, ActualFrequency, sinpars(igrat).tfreq);    end        % Make movies    fprintf(1,' Frames for grating %d...', igrat);    % flickering    ContrastTrace = sin(TemporalPhase);    ContrastImage = sin(AngFreqs);    ContrastImage = sign(ContrastImage).*abs(ContrastImage).^beta;%     if sqwv%         ContrastImage = (ContrastImage>0.01)-(ContrastImage<-0.01);%     end    Frames{igrat} = cell(nFramesInPeriod,1);    for iframe = 1:nFramesInPeriod        Frames{igrat}{iframe} = ContrastTrace(iframe) .* ContrastImage .* WindowImage;    end        % the frame sequence    %FrameSequence{igrat} = 1+mod(1:nframes,nFramesInPeriod);    FrameSequence{igrat}(1:frmSwitchStTE-1) = 1;    FrameSequence{igrat}(frmSwitchStTE:frmSwitchEnTE-1) = 1+mod(1:frmSwitchEnTE-frmSwitchStTE,nFramesInPeriod);    FrameSequence{igrat}(frmSwitchEnTE:frmSwitchStTL-1) = 1;    FrameSequence{igrat}(frmSwitchStTL:frmSwitchEnTL-1) = 1+mod(1:frmSwitchEnTL-frmSwitchStTL,nFramesInPeriod);    FrameSequence{igrat}(frmSwitchEnTL:nframes) = 1;    end    %% merge the stimuli% probably obsoleteoglStim.nperiods             = 1; % plobably important oglStim.srcRect = cell(2*nframes,1);% is this unused? what is it???% should be {240x1 cell}, and each of them should be {[],[]}% for iframe = 1:(2*nframes% 	oglStim.srcRect{iframe} = {[] []};% endoglStim.frames   = {[Frames{1}(:); Frames{2}(:) ]};% probably obsoleteoglStim.luts     =  { repmat([128 255 0 1:253]',1,3) repmat([128 255 0 1:253]',1,3) }';% importantoglStim.sequence.frames = [ FrameSequence{1}; (FrameSequence{2}+ length(Frames{1}) ) ];oglStim.sequence.frames = oglStim.sequence.frames(:);% probably obsoleteoglStim.sequence.luts   = [ ones(1,nframes)  ; ones(1,nframes) + 1 ];oglStim.sequence.luts   = oglStim.sequence.luts  (:);% probably importantoglStim.positionIndex = repmat([1; 2], nframes, 1);fprintf(1,'\n');return%% TO TEST IT:% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb2 x2 y2 flick2 sqwv2 duty2 shape2]myscreen = ltScreenInitialize(2); %#ok<UNRCH>myscreen.Dist = 20;ltLoadCalibration(myscreen);% ltClearStimulus(Stim,'nowarnings');pars = [ 20 ...    10 10 180  0  50   0 100 300 0 0 1 1 100 0 ...    10 20   0  0   0  90   0 300 0 0 0 0 100 0 ];pars = [ 20 ...    25 10   0  0 50  90  100 300 0 0 0 0 100 0 ...    10 10 180  0 50   0   99 500 0 0 0 0 100 1 ];% Stim = oglTwoGratings(pars,myscreen);% Stim = vsLoadTextures(myscreen, Stim);% Stim = oglStimMake( 'visdriftsin', [20 20 20 50 30 0 0 30],myscreen); % newpars = [20 20 20 40 30 0 0 30]; Stim = oglStimMake('oglTwoGratings',pars, myscreen);oglStimPlay(myscreen,Stim);newpars = [ 20 ...    25 10   0  0 25  45  100 300 200 0 0 0 100 0 ...    10 10 180  0 25   0   99 500   0 0 0 0 100 1 ];Stim = oglStimUpdateDisplayParameters(Stim,newpars,myscreen);vsPlayStimulus_c(myscreen, Stim, RushOrNoRush, PlayOrShow, SerialPort, LBflag, [0 0 1 0])ltClearLoadedTextures;ltClearStimulus(Stim,'nowarnings');Screen('CloseAll');