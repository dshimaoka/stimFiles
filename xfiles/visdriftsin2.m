function Stim =  visdriftsin2(pars,myscreen)% Stim =  visdriftsin2(pars,myscreen)%% code for visdriftsin2.x%% 2000-01 TCB and MC % 2000-04 MC cleaned up a lot. Now it returns Stim, and does not play it.% ------ parse the pars (excuse the pun)dur 	= pars(1)/10 /2; %= dur; % Stim. durationpatch(1).tf	 	= pars(2)/10 * 2; 	patch(1).sf  	= pars(3)/10; 		patch(1).c 	 	= pars(4)/100 * 2; patch(1).ori 	= pars(5) * (pi/180); patch(1).x	 	= ceil(ltdeg2pix(pars(6)/10,myscreen)); % Centre x (deg/10).patch(1).y		= ceil(ltdeg2pix(pars(7)/10,myscreen)); % Centre y (deg/10).patch(1).diam	= ceil(ltdeg2pix(pars(8)/10,myscreen)); % diameter (deg/10).patch(2).tf		= pars(9)/10 * 2; patch(2).sf 	= pars(10)/10; patch(2).c 		= pars(11)/100 * 2; patch(2).ori 	= pars(12) * (pi/180); patch(2).x		= ceil(ltdeg2pix(pars(13)/10,myscreen)); % Centre x (deg/10).patch(2).y		= ceil(ltdeg2pix(pars(14)/10,myscreen)); % Centre y (deg/10).patch(2).diam	= ceil(ltdeg2pix(pars(15)/10,myscreen)); % diameter (deg/10).% ------ convert them into relevant fields in SinParsSinPars = [];for ipatch = 1:2	SinPars(ipatch).x 				 = patch(ipatch).diam; 	SinPars(ipatch).y 				 = patch(ipatch).diam;	SinPars(ipatch).Contrast		 = patch(ipatch).c;	SinPars(ipatch).Orientation 	 = patch(ipatch).ori;	% radians	SinPars(ipatch).SpatialFrequency = patch(ipatch).sf;	% Cycles/degree	SinPars(ipatch).tFreq			 = patch(ipatch).tf;	% Hz % 	SinPars(ipatch).outerRad 		 = round(patch(ipatch).diam/2); % pixels!end% ------ other SinPars fields to be setfor ipatch = 1:2	SinPars(ipatch).phase			 = 0;	% 0 is cosine phase	SinPars(ipatch).sqwv			 = 0;	% 0=sine, 1=square	SinPars(ipatch).innerRad 		 = 0;	% pixels!end% ------ other pars to be keptctr = [];for ipatch = 1:2	ctr(ipatch).x = patch(ipatch).x;	ctr(ipatch).y = patch(ipatch).y;endnframes = round(myscreen.FrameRate * dur);% ------ that's it, no more use for patchclear patch%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim = cell(2,1);for ipatch = 1:2		Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);		[Cluts1, nCluts1] = ltMakeGratingCluts(SinPars(ipatch),myscreen,'reserve3');	for ii = 1:nCluts1		Stim{ipatch}.luts{ii} = squeeze(Cluts1(ii,:,:)); % why???	end	Stim{ipatch}.sequence.frames = ones(1,nframes);	for ii = 0:nframes - 1		Stim{ipatch}.sequence.luts(ii+1) = mod(ii,nCluts1) + 1;	end	%------- define position rect	x1 = (round(myscreen.Xmax/2) - SinPars(ipatch).x/2);	y1 = (round(myscreen.Ymax/2) - SinPars(ipatch).y/2);	x2 = (round(myscreen.Xmax/2) + SinPars(ipatch).x/2);	y2 = (round(myscreen.Ymax/2) + SinPars(ipatch).y/2);		Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr(ipatch).x,ctr(ipatch).y);		Stim{ipatch}.nperiods = 1;	end