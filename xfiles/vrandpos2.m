function [Stim, NoisePars] = vrandpos2(pars,myscreen)% "smarter" randpos stimulus based on the original version by RF%%% [Stim, NoisePars] =  vrandpos(pars,myscreen);%% Parameters are :% [dur c x y diam barwdth sf nori npos nphase seed nfr]%% 2008-01 LB% ------ parse the parametersp.dur 		= pars(1)/10; % duration.p.c			= pars(2)/100; % contrastp.x			= ceil(ltdeg2pix(pars(3)/10,myscreen)); % Center x (deg/10).p.y			= ceil(ltdeg2pix(pars(4)/10,myscreen)); % Center y (deg/10).p.diam		= ceil(ltdeg2pix(pars(5)/10,myscreen)); % width (deg/10).p.barwdth   = ceil(ltdeg2pix(pars(6)/10,myscreen)); % width of bar (deg/10).p.sf        = pars(7)/100; %spatial frequency (sf/100);p.nori		= pars(8); % number of orientationsp.npos      = pars(9); %number of stimulus positions (per orientation)p.nphase	= pars(10); % the number of spatial phasesp.seed		= pars(11); % the seed of random number generatorp.nfr		= pars(12); % the number of interpolated framesp.bprob		= pars(13)./100; %the probability of a blank screen (in %)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The radius of the stimulip.outerRad = round(p.diam/2);% Make a grid of x and ynx = 2*p.outerRad;ny = 2*p.outerRad;[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);window = ( xx.^2+yy.^2 < p.diam^2/4 ); % circular window% Compute the orientations of the stimuliif p.nori < 2	dori = 0;	p.nori = 1;else	oridist = angle(exp(i*pi));	% There is no motion, oris is between 0 and pi	if oridist < 0;		dori = pi/p.nori;	else		% This makes sure that the first and last oris are not too similar		dori = oridist/(p.nori-1);		if pi-(p.nori-1)*dori < dori			dori = pi/p.nori;		end	endenddiffori = zeros(1,p.nori);diffori(1) = 0;for iori = 2:p.nori	diffori(iori) = diffori(iori-1) + dori;enddiffori = mod(diffori,2*pi); % these are the orientations used, expressed as anglesdifforideg = diffori * 180 / pi; % convert to deg% Compute the positions of the stimuliif p.npos < 2    dpos = 0;    p.npos = 1;    diffpos = 0;else    dpos = round((p.diam-p.barwdth)./(p.npos-1));    diffpos = dpos.*linspace(-(p.npos-1)./2, (p.npos-1)./2,p.npos);end% Compute the phases of the stimuliif p.nphase > 1	diffph = (0:2*pi:2*pi*(p.nphase - 1))/p.nphase;else	diffph = 0;	p.nphase = 1;end% MAKE ALL THE FRAMES% mymovie = cell(p.nori*p.nphase*p.npos,1);mymovie = cell(p.nphase*p.npos,1);iframe = 0;thissf = 1./ltdeg2pix(1/p.sf,myscreen); % sf in cycles/pixfor ipos = 1:p.npos%	for iori = 1:p.nori		for iph = 1:p.nphase			iframe = iframe+1;            thispos = diffpos(ipos);			thisori = 0; % diffori(iori); stimulus will be rotated during presentation			thisphase = diffph(iph);			%make the stimulus aperture            aperture = ( cos(thisori).*xx + sin(thisori).*yy ) < (thispos + p.barwdth/2) & ( cos(thisori).*xx + sin(thisori).*yy ) > (thispos - p.barwdth/2);            % the minus sign below is for consistency with the orientation of other stimuli			angfreq = -2*pi*thissf*( cos(thisori).*xx + sin(thisori).*yy );            % introduce a phase correction for the offset of the window.            phzcorr = 2.*pi.*thispos.*thissf;            % EDITED BY MC AND AB 2006-03-20: sin TO cos			movieimage = p.c * cos( phzcorr + thisphase + angfreq );			mymovie{iframe} = uint8(round(( movieimage.*window.*aperture + 1 )*126 + 3)); 			% and at this point movieimage goes bet 3 and 255		end%	endendif p.bprob > 0	% ngrat = p.nori*p.nphase.*p.npos;    ngrat = p.nphase * p.npos;	nblnk = round(ngrat.*(1/p.bprob-1).^-1);	% the adaptor frames	for ibl = 1:nblnk		iframe = iframe+1;		movieimage = zeros(size(xx));		mymovie{iframe} = uint8(round(( movieimage.*window + 1 )*126 + 3)); 		% and at this point movieimage goes bet 3 and 255	end	end% That's it for the framesStim.frames{1} = mymovie;%Stim = ltMakeOffScreenWindows(myscreen,Stim,1);% % MAKE ALL THE LUTSlinClut = [ [128 128 128]; [255 255 255]; [ 0 0 0]; round(linspace(0,255,253))'*[1 1 1] ];Stim.luts{1} = linClut;% The number of frames in the entire stimulusnframes = ceil(p.dur * myscreen.FrameRate);Stim.sequence.luts = ones(1,nframes);% The position of the stimulusx1 = round(myscreen.Xmax/2) - round(p.diam/2);y1 = round(myscreen.Ymax/2) - round(p.diam/2);x2 = round(myscreen.Xmax/2) + round(p.diam/2);y2 = round(myscreen.Ymax/2) + round(p.diam/2);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);% DEFINE THE RANDOM SEQUENCE OF THE FRAMES% Set the seed, and select the Matlab 4 rand num generatorrand('seed',p.seed);% The number of images that contain a grating% ngrat = p.nori*p.nphase*p.npos+nblnk;ngrat = p.nphase * p.npos + nblnk;% The sequence of frames (position and spatial phase)frameseq = min(ngrat ,ceil(rand(1,nframes)*ngrat)); % number of frames% The sequence of orientationsoriIndex = ceil(rand(1,nframes)*p.nori);% Interpolate these frames frameindex = floor(1:1/p.nfr:nframes);Stim.sequence.frames = frameseq(frameindex(1:nframes));Stim.ori = difforideg(oriIndex(frameindex(1:nframes)));% The number of times you want to see the movie		Stim.nperiods = 1;Stim.globalAlpha = ones(1,nframes);Stim.srcRect = cell(1,nframes);iframe = 0;for ipos = 1:p.npos    for iori = 1:p.nori        for iph = 1:p.nphase            iframe = iframe+1;            NoisePars.ori(iframe) = diffori(iori)/pi*180;            NoisePars.pos(iframe) = diffpos(ipos); % SF in cpd            NoisePars.phase(iframe) = diffph(iph)/pi*180;        end    endendNoisePars.c = p.c*ones(1,p.npos*p.nori*p.nphase);if p.bprob > 0	ngrat = p.nori*p.nphase.*p.npos;	nblnk = round(ngrat.*(1/p.bprob-1).^-1);    % the adaptor frames    for ibl = 1:nblnk        iframe = iframe+1;        NoisePars.ori(iframe) = NaN;        NoisePars.pos(iframe) = NaN;        NoisePars.phase(iframe) = NaN;        NoisePars.c(iframe) = 0;    endendreturn%-------------------------------------------------------------% Code to test the function% % The screen% myscreen.FrameRate = 124.8794; % Hz;% myscreen.Dist = 57;% myscreen.PixelSize = 1/6;% myscreen.Xmax = 30 /myscreen.PixelSize; % sets height to 30 deg% myscreen.Ymax = 20 /myscreen.PixelSize; % sets width  to 20 degwhichScreen = 1;myscreen = ltScreenInitialize(whichScreen);myscreen.Dist = 57;% The parametersdur 		= 100; % sec*10c			= 50; % contrast in %x			= 45; % Centre x (deg/10).y			= -39; % Centre y (deg/10).diam		= 1000; % diameter (deg/10).barwdth		= 20; % number of orientationssf			= 40; %spatial frequencies (sf/100)nori        = 4;   %number of orientationsnpos        = 4;   %number of positions of the barsnphase		= 2; % the number of spatial frequenciesseed		= 1; % the seed of random number generatornfr			= 1; % the number of interpolated framesbprob       = 10; % percent chance that the stimulus is blankpars = [dur c x y diam barwdth sf nori npos nphase seed nfr bprob];tic; Stim = vrandpos2(pars,myscreen); tocStim = vsLoadTextures(myscreen, Stim);vsPlayStimulus(myscreen,Stim,'norush');ltClearStimulus(Stim,'nowarnings');% Let's see whether this is what it is supposed to be% The sequence of imagesnimg = length(Stim.frames{1});figure;[yy, xx] = hist(Stim.sequence.frames,1:nimg);bar(xx, yy/length(Stim.sequence.frames) )% The sum over all imagessumall = zeros(size(Stim.frames{1}{1}));for iframe = 1:nimg	sumall = sumall + double(Stim.frames{1}{iframe});endsumall = uint8(sumall/nimg);figure;imagesc(sumall);colormap gray; colorbar;% Look at individual framesfigure;iframe = 1;for iframe = 1:length(Stim.frames{1})	subplot(6,6,iframe);	imagesc(Stim.frames{1}{iframe});	colormap gray;	axis equal	set(gca,'xtick',[],'ytick',[])end