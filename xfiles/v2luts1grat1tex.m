function Stim =  v2luts1grat1tex(pars,myscreen)% Stim =  v2luts1grat1tex(pars,myscreen)%% SEE CODE AT THE END OF THE FUNCTION TO TEST % ------ parse the pars (excuse the pun)SinPars = [];dur 	= pars(1)/10 ; %= dur; % Stim. durationctr.x	 			=  round(ltdeg2pix(pars (2)/10,myscreen)); % Centre x (deg*10).ctr.y				=  round(ltdeg2pix(pars( 3)/10,myscreen)); % Centre y (deg*10).SinPars.tFreq	 			= pars(4)/10 * 2; 	% 2x factor since presented every other framesSinPars.SpatialFrequency  	= pars(5)/100; 		SinPars.phase  				= pars(6)* (pi/180); 		SinPars.Contrast 	 		= pars(7)/100 * 2; % 2x factor since presented every other framesSinPars.Orientation 		= pars(8) * (pi/180); SinPars.innerRad			=  ceil(ltdeg2pix(pars( 9)/10,myscreen)/2); % inner diameter (deg*10).SinPars.outerRad			= floor(ltdeg2pix(pars(10)/10,myscreen)/2); % outer diameter (deg*10).SinPars.sqwv	= 0;	% 0=sine, 1=squareTexPars = [];TexPars.x = ctr.x;TexPars.y = ctr.y;TexPars.texelsize = ceil(ltdeg2pix(pars( 11)/10,myscreen)); % size of texture elements (deg*10)TexPars.tFreq = pars(12) / 10 * 2; % modulation frequency (Hz*10), 2x factor since presented every other framesTexPars.innerRad =  ceil(ltdeg2pix(pars(13)/10,myscreen)/2); % inner diameter (deg*10).TexPars.outerRad = floor(ltdeg2pix(pars(14)/10,myscreen)/2); % outer diameter (deg*10).TexPars.order = pars(15); % order of moment to vary (0,1,2,3,4,5)TexPars.moddepth = pars(16)/100; % modulation depth of deviations from uniform distr (0 to 100%).TexPars.statetex = pars(17); % seed of random sequence underlying texture generationTexPars.sqwv = pars(18); % modulation waveform. sine:0,sqwv:1%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if TexPars.outerRad == 0	Stim = cell(1,1);	nframes = round(myscreen.FrameRate * dur);	SinPars.tFreq = SinPars.tFreq /2;	SinPars.Contrast = SinPars.Contrast /2;else	Stim = cell(2,1);	nframes = round(myscreen.FrameRate * dur / 2);end%%%%%%%%%%%%%%% test gratingipatch = 1;Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars,myscreen,'reserve3');Stim{ipatch}= ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);[Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');Stim{ipatch}.luts = cell(nCluts,1); % allocationfor iClut = 1:nCluts	Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); endStim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initializationStim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation onlyfor iframe = 0:nframes - 1 % initialization	Stim{ipatch}.sequence.luts(iframe+1) = mod(iframe,nCluts) + 1;end%------- define position rectx1 = (round(myscreen.Xmax/2) - SinPars.outerRad);y1 = (round(myscreen.Ymax/2) - SinPars.outerRad);x2 = (round(myscreen.Xmax/2) + SinPars.outerRad);y2 = (round(myscreen.Ymax/2) + SinPars.outerRad);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim{ipatch}.nperiods = 1;%%%%%%%%%%%%%% mask texture if TexPars.outerRad==0; 	Stim = Stim{ipatch};	return;end;ipatch =2;persistent mystorage;currentkey =sprintf('%i %i %i %i',TexPars.texelsize,TexPars.innerRad,...					TexPars.outerRad,TexPars.statetex);if isfield(mystorage,'keyframes') & isfield(mystorage,'frames') & strcmp(mystorage.keyframes,currentkey)	Stim{ipatch}.frames = mystorage.frames;else	frames = {};	% use new random generator. use seed from parameter.	rand('state',TexPars.statetex);		for iframe = 1: nframes;	    frames{1}{iframe} = makeTextureFrame(TexPars);	end	Stim{ipatch}.frames = frames;	mystorage.keyframes = currentkey;	mystorage.frames = frames;endStim{ipatch}= ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);if isfield(mystorage,'basisfunctions')	bf = mystorage.basisfunctions;else	nsamples = 256;	bf = makeBasisFunctions(nsamples);	mystorage.basisfunctions = bf;%	disp('setup persistent storage');endStim{ipatch}.luts = makeTextureClut(TexPars,myscreen,bf);% % generate unique frames sequence% % number of unique frames: nframes / TexPars.refreshrate % uframes 	= ... % for allocation and initialization%     mod(floor(rand(1,ceil(nframes/TexPars.refreshrate))*ntexframes),ntexframes)+1;% % % upsample frame sequence according to refresh rate% so = size(uframes);% sn = so*TexPars.refreshrate;% sc = so./sn + eps;% actual scaling between images, eps is needed% frames =  uframes(floor(sc(1)/2:sc(1):end)+1);% % % discard additional frames% Stim{ipatch}.sequence.frames = frames(1:nframes);Stim{ipatch}.sequence.frames = 1:nframes; % for allocation and initializationnCluts = length(Stim{ipatch}.luts);Stim{ipatch}.sequence.luts 		= mod([0:nframes-1],nCluts) +1;%------- define position rect[nx,ny]=size(Stim{2}.frames{1}{1});x1 = (round(myscreen.Xmax/2) - nx/2);y1 = (round(myscreen.Ymax/2) - nx/2);x2 = (round(myscreen.Xmax/2) + nx/2);y2 = (round(myscreen.Ymax/2) + nx/2);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);% The number of times you want to see the movie		Stim{ipatch}.nperiods = 1;returnfunction [luts,actualTFreq] = makeTextureClut(TexPars,myscreen,rescf)% generate nonorthogonal basis. % vectors are monomes with increasing ordernsamples = length(rescf)+1;if TexPars.tFreq>0	nCluts=round(myscreen.FrameRate/TexPars.tFreq);	% number of frames per cycle	actualTFreq=myscreen.FrameRate/nCluts; % calculate actual temporal freq (Hz)else	nCluts = 1;	actualTFreq=0;endluts = {};vv = linspace(0,1,nsamples);% range 0-252 gives 253 entries.% 3 additional lut entries reserved for gray, black and white.nreslutentries = 3;for ilut = 1:nCluts		if TexPars.tFreq==0		magnitude=TexPars.moddepth;	else		if TexPars.sqwv			if (ilut-1)/nCluts < 0.5;sig=1;else;sig=-1;end;			magnitude = TexPars.moddepth*sig;		else			magnitude = TexPars.moddepth*sin((ilut-1)/nCluts*2*pi);		end	end		% pdf is sum uniform distribution with a basis function	% f(x) = P{X==x}	density = rescf(:,1) + magnitude*rescf(:,TexPars.order+1);	% patch to enforce monotonic distribution.	density(find(density<=1e-6))=1e-6;	% F(x) = P{X<=x}	distr(1)=0;	distr(2:nsamples)=cumsum(density);	% F^-1(x)	w = linspace(0,1,256-nreslutentries);	invdistr = interp1(distr,vv,w,'linear'); % dropped 'extrap' 	invdistr(1)=0; % first point can't be interpolated 	invdistr(end)=1; % last point can't be interpolated	if any(isnan(invdistr))		disp('WARNING (v2luts1grat1tex): nan values found in inverse distribution');		disp(find(isnan(invdistr)));	end		norminvdistr = max(0,invdistr/max(invdistr))*255;	luts{ilut} = zeros(256,3);	luts{ilut}(1,1:3) = 128;	luts{ilut}(2,1:3) = 255;	luts{ilut}(3,1:3) = 0;	luts{ilut}(4:256,1:3) = repmat(norminvdistr',1,3);end % for ilutreturn;function Qhat = gram_schmidt(a);%   gram_schmidt   -  script implementing the step-by-step%               Gram-Schmidt algorithm.%%[ rowsA, colsA ] = size(a) ;%Qhat = a(:,1)/norm(a(:,1)); %for j = 2:colsA  Qhat(:,j) = a(:,j) - Qhat*(Qhat'*a(:,j)) ;  Qhat(:,j) = Qhat(:,j)/norm( Qhat(:,j) );endfunction imframe = makeTextureFrame(TexPars)ntexels = ceil(TexPars.outerRad * 2 / TexPars.texelsize);% generate equally distributed numbers% note that P(256)~=0 but isvery small.% later we cast the array onto uint8, which replaces all 256s with 0s.lowerbound = 3;upperbound = 255;frame = floor(rand(ntexels,ntexels)*((upperbound-lowerbound)+1))+lowerbound;% upsample to obtain image with desired texel size.so = size(frame);sn = so*TexPars.texelsize;sc = so./sn + eps;% actual scaling between images, eps is neededscframe =  frame(floor(sc(1)/2:sc(1):end)+1,floor(sc(2)/2:sc(2):end)+1,:);% circular window. image size always even because specified by radius.xx = round([0:sn(1)-1]-sn(1)/2);[XX,YY]=meshgrid(xx,xx);if any(size(XX)~=size(scframe));	disp('texture array size does not macht that of aperture');endsel = find(XX.^2+YY.^2>TexPars.outerRad.^2 | XX.^2+YY.^2<TexPars.innerRad.^2);scframe(sel)=0; % background is grayimframe = uint8(scframe);returnfunction [rescf]=makeBasisFunctions(nsamples)		v = linspace(0,1,nsamples-1)'; % pdf has one sample less than the distr.	nv = length(v);	f = [];	for i = 1 : nv;	    f(1:nv,i)=v.^(i-1);	end		% orthogonalize basis	orthf = gram_schmidt(f);		% plot(v,orthf(:,1:5),'o-');		% normalize such that basis represents pdfs and	% that each vector corresponds to 	% maximal modulator of the uniform distribution.	ulevel = 1/nv; % uniform distribution.	nvectors = 6; % only compute the first 6 basis vectors	for i =1:nvectors	    mlevel(i) = max(abs(orthf(:,i)));	    rescf(:,i) = orthf(:,i)/abs(mlevel(i))*ulevel;	endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);clear Stim1;% pars:= [ dur x y tf1 sf1 ph1	c1 ori1 idiam1 odiam1     tex tf idiam2 odiam2 n depth seed sqwv]Stim1 = v2luts1grat1tex([ 40 0 0 20 10 0 0   0  0 40    5 10 30 0 2 100 99 0],myscreen);Stim2 = v2luts1grat1tex([ 40 0 0 20 10 0 0   0  0 40    4 10 30 100 3 100 99 1],myscreen);Stim3 = v2luts1grat1tex([ 20 0 0 20 10 0 0 90  0 40    4 10 40 90 1   100 99 0],myscreen);vsPlayStimulus(myscreen,Stim1);vsPlayStimulus(myscreen,Stim2);vsPlayStimulus(myscreen,Stim3);ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');