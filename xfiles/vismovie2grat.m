function Stim =  vismovie2grat(pars,myscreen)% Stim =  vismovie2grat(pars,myscreen)%% pars are [dur tf1 sf1 ph1 c1 ori1 irad1 orad1 tf2 sf2 ph2 c2 ori2 irad2 orad2 x y]% pars = [10 40 30 0 50 0 0 100 20 30 0 50 90 0 100 0 0]%% code for vismovie2grat.x%% 2003-11 VM and AB, from vis2luts2grats % % Stim =  vismovie2grat(pars,myscreen)% Durationdur 	= pars(1)/10; %= dur; % Stim. durationSinPars = [];% First gratingsinpars(1).tfreq	 			   = pars(2)/10; 	sinpars(1).spatialfrequency  	= pars(3)/100; 		sinpars(1).phase  				= pars(4) * (pi/180); 		sinpars(1).contrast 	 		   = pars(5)/100; sinpars(1).orientation 			= pars(6) * (pi/180); sinpars(1).innerrad			   = ceil(ltdeg2pix(pars(7)/10,myscreen)/2); % inner diameter (deg/10).sinpars(1).outerrad			   = floor(ltdeg2pix(pars(8)/10,myscreen)/2); % outer diameter (deg/10).% Second gratingsinpars(2).tfreq	 			   = pars(9)/10; 	sinpars(2).spatialfrequency  	= pars(10)/100; 		sinpars(2).phase  				= pars(11) * (pi/180); 		sinpars(2).contrast 	 		   = pars(12)/100; sinpars(2).orientation 			= pars(13) * (pi/180); sinpars(2).innerrad			   = ceil(ltdeg2pix(pars(14)/10,myscreen)/2); % inner diameter (deg/10).sinpars(2).outerrad			   = floor(ltdeg2pix(pars(15)/10,myscreen)/2); % outer diameter (deg/10).% The same position for both gratingsctr.x	 = round(ltdeg2pix(pars(16)/10,myscreen)); % Centre x (deg/10).ctr.y	 = round(ltdeg2pix(pars(17)/10,myscreen)); % Centre y (deg/10).% Make sure that the contrasts do make senseir1 = sinpars(1).innerrad;or1 = sinpars(1).outerrad;ir2 = sinpars(2).innerrad;or2 = sinpars(2).outerrad;if (ir2 > ir1 & ir2 < or1) | (or2 > ir1 & or2 < or1) | ...	ir1 == ir2 | or1 == or2	if sinpars(1).contrast + sinpars(2).contrast > 1		beep = makebeep(700,.5);		snd('play',beep);		disp('CONTRAST IS TOO LARGE!!!');	endend% Duration, independent on temporal frequenciesnframes = round(myscreen.FrameRate * dur);% The time axistaxis = (0:(nframes-1)) / myscreen.FrameRate;% Spatial frequency in cycles/pixel% First gratingDegPerCycle(1) = 1/sinpars(1).spatialfrequency;PixPerCycle(1) = ltdeg2pix(DegPerCycle(1),myscreen);sinpars(1).frequency = 1/PixPerCycle(1); % sf in cycles/pix% Second gratingDegPerCycle(2) = 1/sinpars(2).spatialfrequency;PixPerCycle(2) = ltdeg2pix(DegPerCycle(2),myscreen);sinpars(2).frequency = 1/PixPerCycle(2); % sf in cycles/pix% The size of the framesmaxrad = max([1, (sinpars(1).contrast > 0)*sinpars(1).outerrad, ...   (sinpars(2).contrast > 0)*sinpars(2).outerrad]);nx = 2*maxrad;ny = 2*maxrad;% Make a grid of x and y[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);% The temporal phase of the responsetphase = zeros(2,nframes);tphase(1,:) = 2*pi*sinpars(1).tfreq*taxis;tphase(2,:) = 2*pi*sinpars(2).tfreq*taxis;% The spatial phase of the stimulus% the minus sign below is for consistency with the orientation of other stimuliangfreq{1} = -2*pi*sinpars(1).frequency*(cos(sinpars(1).orientation).*xx + ...   sin(sinpars(1).orientation).*yy ) + sinpars(1).phase;angfreq{2} = -2*pi*sinpars(2).frequency*(cos(sinpars(2).orientation).*xx + ...   sin(sinpars(2).orientation).*yy ) + sinpars(2).phase;% in radians% The annular window of the stimulidd = sqrt(xx.^2+yy.^2);win{1} = double(dd >= sinpars(1).innerrad  & dd <= sinpars(1).outerrad);win{2} = double(dd >= sinpars(2).innerrad  & dd <= sinpars(2).outerrad);% Make moviesif sinpars(1).contrast > 0 | sinpars(2).contrast > 0      % Make the frames   if sinpars(1).contrast > 0 & sinpars(2).contrast > 0      % Both frames are non-blank            for iframe = 1:nframes		  fprintf(1,'.');		  if ~mod(iframe,40), fprintf(1,'\n'); end         grat{1} = sinpars(1).contrast * sin(angfreq{1} + tphase(1,iframe)) .* win{1};         grat{2} = sinpars(2).contrast * sin(angfreq{2} + tphase(2,iframe)) .* win{2};         Stim.frames{1}{iframe} = uint8((grat{1} + grat{2} + 1)*252/2 + 3);           end      else       % Pick the only frame that is not blank      if sinpars(1).contrast > 0         igood = 1;      else         igood = 2;      end            for iframe = 1:nframes         grat{1} = sinpars(igood).contrast * sin(angfreq{igood} + tphase(igood,iframe)) .* win{igood};         Stim.frames{1}{iframe} = uint8((grat{1} + 1)*252/2 + 3);           end   end      % Make the lookup table   baselut = [128 255 0 round(linspace(3,255,253))]';   Stim.luts{1} = [baselut baselut baselut];      % Make sequence   Stim.sequence.frames = 1:nframes;   Stim.sequence.luts = ones(1,nframes);   else   % The blank frame   Stim.frames{1}{1} = zeros(size(xx));      % The lookup table   baselut = [128 255 0 round(linspace(3,255,253))]';   Stim.luts{1} = [baselut baselut baselut];      % The sequence   Stim.sequence.frames = ones(1,nframes) * NaN;   Stim.sequence.frames(1) = 1;   Stim.sequence.luts = ones(1,nframes);endStim = ltMakeOffScreenWindows(myscreen,Stim,1);% The position vectorx = round(myscreen.Xmax/2 - maxrad);y = round(myscreen.Ymax/2 - maxrad);Stim.position(1,:) = [x y x+nx y+ny];Stim.nperiods = 1;return%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 25;ltLoadCalibration(myscreen,3);% [  dur ...%    tf1 sf1 ph1 c1 ori1 irad1 orad1 ...%    tf2 sf2 ph2 c2 ori2 irad2 orad2 ...%    x y ]pars = [30 ...        40 10 0  50 90   0  90 ...		30 10 0  50 45 140 250 ...		0 0];		Stim = vismovie2grat(pars,myscreen);vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');