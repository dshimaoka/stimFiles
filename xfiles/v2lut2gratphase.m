function Stim =  v2lut2gratphase(pars,myscreen)% Stim =  v2lut2gratphase(pars,myscreen)%% code for v2lut2gratphase.x%% Just like vis2lut2gratdel but can vary temporal phase%% Parameters are % [ dur ...%	tf1 tph1 sf1 sph1 c1 ori1 x1 y1 idiam1 odiam1 sqwv1 flicker1%	tf2 tph2 sf2 sph2 c2 ori2 x2 y2 idiam2 odiam2 sqwv2 flicker2 %   delay ]%% SEE CODE AT THE END OF THE FUNCTION TO TEST dur 							= pars(1)/10 /2; %= dur; % Stim. durationSinPars = [];SinPars(1).tFreq	 			= pars(2)/10 * 2; 	SinPars(1).TempPhase  			= pars(3)* (pi/180); 		SinPars(1).SpatialFrequency  	= pars(4)/100; 		SinPars(1).phase  				= pars(5)* (pi/180); 		SinPars(1).Contrast 	 		= pars(6)/100 * 2; SinPars(1).Orientation 			= pars(7) * (pi/180); ctr(1).x	 					= round(ltdeg2pix(pars (8)/10,myscreen)); % Centre x (deg/10).ctr(1).y						= round(ltdeg2pix(pars( 9)/10,myscreen)); % Centre y (deg/10).SinPars(1).innerRad				=  ceil(ltdeg2pix(pars(10)/10,myscreen)/2); % inner diameter (deg/10).SinPars(1).outerRad				= max(1,floor(ltdeg2pix(pars(11)/10,myscreen)/2)); % outer diameter (deg/10).SinPars(1).sqwv					= pars(12);	% 0=sine, 1=squareSinPars(1).direction 			= (pars(13)==0);SinPars(2).tFreq	 			= pars(14)/10 * 2; 	SinPars(2).TempPhase  			= pars(15)* (pi/180); 		SinPars(2).SpatialFrequency  	= pars(16)/100; 		SinPars(2).phase  				= pars(17)* (pi/180); 		SinPars(2).Contrast 	 		= pars(18)/100 * 2; SinPars(2).Orientation 			= pars(19) * (pi/180); ctr(2).x	 					=  round(ltdeg2pix(pars(20)/10,myscreen)); % Centre x (deg/10).ctr(2).y						=  round(ltdeg2pix(pars(21)/10,myscreen)); % Centre y (deg/10).SinPars(2).innerRad				=   ceil(ltdeg2pix(pars(22)/10,myscreen)/2); % inner diameter (deg/10).SinPars(2).outerRad				= max(1,floor(ltdeg2pix(pars(23)/10,myscreen)/2)); % outer diameter (deg/10).SinPars(2).sqwv					= pars(24);	% 0=sine, 1=squareSinPars(2).direction 			= (pars(25)==0);delay 							= pars(26)/10 /2; %= dur; % initial delaynframes = round(myscreen.FrameRate * dur);ndelayframes = round(myscreen.FrameRate * delay); % these should be blanknstimframes  = nframes - ndelayframes;if nstimframes < 0	warning('-----> Delay is longer than stimulus!!!');	nstimframes = 0;	ndelayframes = nframes;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim = cell(2,1);% Define blanklut..blanklut=127*ones(256,3);blanklut(1,:) = 128;blanklut(2,:) = 255;blanklut(3,:) = 1;for ipatch = 1:2		Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);		[Cluts, nCluts] = ltMakeGratingCluts(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch}.luts = cell(nCluts+1,1); % allocation	for iClut = 1:nCluts		Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); 	end	Stim{ipatch}.luts{iClut+1} = blanklut;	Stim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initialization	Stim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation only	for iframe = 1:ndelayframes		Stim{ipatch}.sequence.luts(iframe) = iClut+1; % this one is the blank	end		for istimframe = 1:nstimframes		Stim{ipatch}.sequence.luts(istimframe+ndelayframes) = mod(istimframe-1,nCluts) + 1;	end		%------- define position rect	x1 = (round(myscreen.Xmax/2) - SinPars(ipatch).outerRad);	y1 = (round(myscreen.Ymax/2) - SinPars(ipatch).outerRad);	x2 = (round(myscreen.Xmax/2) + SinPars(ipatch).outerRad);	y2 = (round(myscreen.Ymax/2) + SinPars(ipatch).outerRad);	x2 = max(x2,x1+1); % must be at least one pixel...	y2 = max(y2,y1+1);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr(ipatch).x,ctr(ipatch).y);		Stim{ipatch}.nperiods = 1;	endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 65;ltLoadCalibration(myscreen,3);dur		= 50;tf 		= [5 5];tph 	= [0 90];sf 		= [40 40];sph		= [0 90];c		= [50  50];ori		= [90 90];x		= [0 0];y		= [0 0];idiam 	= [0 60];odiam 	= [30 100];sqwv	= [1 1];flicker	= [1 1];delay 	= 0;pars = [ dur ...	tf(1) tph(1) sf(1) sph(1) c(1) ori(1) x(1) y(1) idiam(1) odiam(1) sqwv(1) flicker(1) ...	tf(2) tph(2) sf(2) sph(2) c(2) ori(2) x(2) y(2) idiam(2) odiam(2) sqwv(2) flicker(2) ...    delay ];Stim = v2lut2gratphase(pars,myscreen);vsPlayStimulus(myscreen,Stim{1},'norush');	vsPlayStimulus(myscreen,Stim{2},'norush');	vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');