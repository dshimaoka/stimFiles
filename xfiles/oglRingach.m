function [Stim, NoisePars] = oglRingach(pars,myscreen)% oglRingach%% Stim =  oglRingach(pars,myscreen);%% [Stim, NoisePars] = oglRingach(pars,myscreen);%% Parameters are :% [dur c x y diam nori orimin orimax nsf sfmin sfmax sflog nphase seed nfr]%% 2008-02 MC from 'vringlogad' and 'oglRandPos'% 2008-03 LB added the computation of NoisePars.screen (for StimFrames)% 2009-11 ND changed active screen from '1' to '0' (main screen) %% parse the parametersp.dur 		= pars(1)/10; % duration.p.c			= pars(2)/100; % contrastp.x			= ceil(ltdeg2pix(pars(3)/10,myscreen)); % Center x (deg/10).p.y			= ceil(ltdeg2pix(pars(4)/10,myscreen)); % Center y (deg/10).p.diam		= ceil(ltdeg2pix(pars(5)/10,myscreen)); % diameter (deg/10).p.nori		= pars(6); % number of orientationsp.orimin	= pars(7)*pi/180; % the 'smallest' orientationp.orimax	= pars(8)*pi/180; % the 'largest' orientationp.nsf		= pars(9); % number of spatial frequenciesp.sfmin		= pars(10)/100; % the smallest spatial frequencyp.sfmax		= pars(11)/100; % the largest spatial frequencyp.sflog		= pars(12); % sfs log-spaced if 1, lin-spaced otherwisep.nphase	= pars(13); % the number of spatial frequenciesp.seed		= pars(14); % the seed of random number generatorp.nfr		= pars(15); % the number of interpolated framesp.aori		= pars(16)*pi/180; % the orientation of the adaptorp.asf		= pars(17)/100; % the spatial frequency of the adaptorp.ac		= pars(18)/100; % the contrast of the adaptorp.aprob		= pars(19)/100; % the probability of the adaptor%% basic calculations% The radius of the stimulip.outerRad = round(p.diam/2);% Make a grid of x and ynx = 2*p.outerRad;ny = 2*p.outerRad;[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);window = ( xx.^2+yy.^2 < p.diam^2/4 ); % circular window% calculate DeltaOriif p.nori < 2    p.nori = 1;elseif p.orimin == p.orimax    DeltaOri = pi/p.nori;else    oridist = angle(exp(1i*(p.orimax-p.orimin)));    % There is no motion, oris is bet 0 and pi    if oridist < 0;        DeltaOri = pi/p.nori;    else        % This makes sure that the first and last oris are not too similar        DeltaOri = oridist/(p.nori-1);        if pi-(p.nori-1)*DeltaOri < DeltaOri            DeltaOri = pi/p.nori;        end    endend% calculate the vector of orientations, difforidiffori = zeros(1,p.nori);diffori(1) = p.orimin;for iori = 2:p.nori    diffori(iori) = diffori(iori-1) + DeltaOri;enddiffori = mod(diffori,2*pi);% calculate the vector of spatial frequencies, diffsfif p.nsf > 1    if p.sflog == 1        diffsf = logspace(log10(p.sfmin),log10(p.sfmax),p.nsf);    else        diffsf = linspace(p.sfmin,p.sfmax,p.nsf);        p.nsf = 1;    endelse    diffsf = p.sfmin;end% calculate the vector of spatial phases, diffphif p.nphase > 1    diffph = (0:2*pi:2*pi*(p.nphase - 1))/p.nphase;else    diffph = 0;    p.nphase = 1;end%% The parameters of each stimulus imageiImage = 0;iMovieFrame = 0;for isf = 1:p.nsf    for iph = 1:p.nphase        iMovieFrame = iMovieFrame+1;        for iori = 1:p.nori            iImage = iImage+1;            NoisePars.ori(  iImage)  = diffori(iori)/pi*180;            NoisePars.sf(   iImage)  = diffsf(isf); % in cpd            NoisePars.phase(iImage)  = diffph(iph)/pi*180;            NoisePars.c(    iImage)  = p.c;            NoisePars.iMovieFrame( iImage ) = iMovieFrame;            % images with different ori share the same MovieFrame        end    endend% then, the adaptorif p.aprob > 0    for iph = 1:p.nphase        iMovieFrame = iMovieFrame+1;        iImage = iImage+1;        NoisePars.ori(  iImage)  = p.aori/pi*180;        NoisePars.sf(   iImage)  = p.asf; % in cpd        NoisePars.phase(iImage)  = diffph(iph)/pi*180;        NoisePars.c(    iImage)  = p.ac;        NoisePars.iMovieFrame( iImage ) = iMovieFrame;     endend%% The random sequence of images% The number of frames in the entire stimulusnframes = ceil(p.dur * myscreen.FrameRate);% Set the seed, and select the Matlab 4 rand num generatorrand('seed',p.seed);% The number of images that contain a grating (not the adaptor)nTestImages = p.nori*p.nphase*p.nsf;% The sequence of imagesVirtualSequence = min(nTestImages ,ceil(rand(1,nframes)*nTestImages));if p.aprob>0    if any(diffori == p.aori) && any(diffsf == p.asf)        % the adaptor is one of the stimuli        padapt = p.nphase/nTestImages;    else        padapt = 0; % probability that the adaptor is shown by chance    end    if p.aprob < padapt        fprintf(1, 'Warning, cannot do a probability that is < %1.2d\n', padapt);    else        pa = (p.aprob - padapt) / (1 - padapt);        % the idea is that p.aprob = pa + (1-pa)*padapt, where:        % p.aprob is the desired probability of the stimulus        % padapt is the probability of the stimulus within the test sequence        % pa is the probability of setting a stimulus to the adapt stimulus.        adaptframes = find(rand(1,nframes)<=pa);        adaptseq = nTestImages + ceil(rand(1,nframes)*p.nphase);        if ~isempty(adaptframes)            VirtualSequence(adaptframes) = adaptseq(adaptframes);        end    endend% Interpolate these frames so that they stay on for p.nfr framesframeindex = floor(1:1/p.nfr:nframes);VirtualSequence = VirtualSequence(frameindex(1:nframes));NoisePars.VirtualSequence = VirtualSequence;%% Make the imagesnMovieFrames = p.nphase*p.nsf;if p.aprob>0, nMovieFrames = nMovieFrames + p.nphase; end    mymovie = cell(nMovieFrames,1);iMovieFrame = 0;for isf = 1:p.nsf    thissf = 1./ltdeg2pix(1/diffsf(isf),myscreen); % sf in cycles/pix    for iph = 1:p.nphase        thisphase = diffph(iph);        thisori = 0;        angfreq = -2*pi*thissf*( cos(thisori).*xx + sin(thisori).*yy );        % the minus sign is for consistency with the orientation of other stimuli        movieimage = p.c * sin( thisphase + angfreq );        iMovieFrame = iMovieFrame+1;        mymovie{iMovieFrame} = uint8(round(( movieimage.*window + 1 )*126 + 3));        % and at this point movieimage goes bet 3 and 255    endendif p.aprob > 0    % the adaptor images    for iph = 1:p.nphase        thisphase = diffph(iph);        thissf = 1./ltdeg2pix(1/p.asf,myscreen); % sf in cycles/pix        angfreq = -2*pi*thissf*( cos( p.aori ).*xx + sin( p.aori ).*yy );        % the minus sign below is for consistency with the orientation of other stimuli        movieimage = p.ac * sin( thisphase + angfreq );        iMovieFrame = iMovieFrame+1;        mymovie{iMovieFrame} = uint8(round(( movieimage.*window + 1 )*126 + 3));        % and at this point movieimage goes bet 3 and 255    endend% That's it for the framesStim.frames{1} = mymovie;% Stim = ltMakeOffScreenWindows(myscreen,Stim,1);%%% Make the look-up-tableslinClut = [ [128 128 128]; [255 255 255]; [ 0 0 0]; round(linspace(0,255,253))'*[1 1 1] ];Stim.luts{1} = linClut;Stim.sequence.luts = ones(1,nframes);% The position of the stimulusx1 = round(myscreen.Xmax/2) - round(p.diam/2);y1 = round(myscreen.Ymax/2) - round(p.diam/2);x2 = round(myscreen.Xmax/2) + round(p.diam/2);y2 = round(myscreen.Ymax/2) + round(p.diam/2);% Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);StimPos = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);Stim.position = repmat( StimPos, [nframes,1] ); % does this work? asks MC.Stim.offset = [p.x p.y];%% The sequence of frames and orisStim.sequence.frames = zeros(1,nframes);for iframe = 1:nframes    iImage = VirtualSequence(iframe);    Stim.ori(iframe) = NoisePars.ori(iImage);     Stim.sequence.frames(iframe) = NoisePars.iMovieFrame(iImage); end% The number of times you want to see the movieStim.nperiods = 1;Stim.globalAlpha = ones(1,nframes);Stim.srcRect = cell(1,nframes);%% Laura's new code to get the screen images 14 Mar 2008% we only need this for the analyses, not when we run an experimentif ~isempty(Screen('Windows'))    returnend% use the size of the first texture as a screen size% safe, because all textures have the same size for one stimulus% ND changed this so that the function would actually run.% [windowPointer]=Screen('OpenWindow',1, 127, [0,0,size(mymovie{1},1), size(mymovie{1},2)]);[windowPointer]=Screen('OpenWindow',0, 127, [0,0,size(mymovie{1},1), size(mymovie{1},2)]);Screen('BlendFunction', windowPointer, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); % needed for alpha blendingiscreen = 0;iMovieFrame = 0;for isf = 1:p.nsf    for iph = 1:p.nphase        iMovieFrame = iMovieFrame+1;        for iori = 1:p.nori            % images with different ori share the same MovieFrame            iscreen = iscreen + 1;            textureIndex = Screen('MakeTexture', windowPointer, Stim.frames{1}{iMovieFrame});            Screen('DrawTexture', windowPointer, textureIndex ,[], [], diffori(iori)/pi*180);            Screen('Flip', windowPointer);            NoisePars.screen{iscreen} = rgb2gray(Screen('GetImage', windowPointer));            Screen('Close', textureIndex);        end    endend% then, the adaptorif p.aprob > 0    for iph = 1:p.nphase        iMovieFrame = iMovieFrame+1;        iscreen = iscreen + 1;        textureIndex = Screen('MakeTexture', windowPointer, Stim.frames{1}{iMovieFrame});        Screen('DrawTexture', windowPointer, textureIndex);        Screen('Flip', windowPointer);        NoisePars.screen{iscreen} = rgb2gray(Screen('GetImage', windowPointer));        Screen('Close', textureIndex);    endendScreen('CloseAll');return%% -------------- Code to test the function -------------------------------myscreen = ltScreenInitialize(1);myscreen.Dist = 57;% SetDefaultDirs% myscreen = ScreenLogLoad('catzfoo',1,1)% The parametersdur 		= 100; % sec*10c			= 50; % contrast in %x			= 45; % Centre x (deg/10).y			= -39; % Centre y (deg/10).diam		= 100; % diameter (deg/10).nori		= 4; % number of orientationsorimin		= 0; % the 'smallest' orientationorimax		= 180; % the 'largest' orientationnsf			= 1; % number of spatial frequenciessfmin		= 50; % the smallest spatial frequencysfmax		= 50; % the largest spatial frequencysflog		= 1; % sfs log-spaced if 1, lin-spaced otherwisenphase		= 4; % the number of spatial frequenciesseed		= 1; % the seed of random number generatornfr			= 1; % the number of interpolated framesaori		= 15;asf			= 50;ac			= 50;aprob 		= 75;pars = [dur c x y diam nori orimin orimax nsf sfmin sfmax sflog nphase seed nfr aori asf ac aprob];[Stim, NoisePars] = oglRingach(pars,myscreen);Stim = vsLoadTextures(myscreen, Stim);vsPlayStimulus(myscreen,Stim);ltClearStimulus(Stim,'nowarnings');