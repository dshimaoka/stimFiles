function [Stim] =  vflickers(pars,myscreen)% Stim =  vsquaretexn(pars,myscreen)%% % SEE CODE AT THE END OF THE FUNCTION TO TEST % fpars=[];dur 	= pars(1)/10 ; %= dur; % Stim. durationx	=  round(ltdeg2pix(pars (2)/10,myscreen)); % Centre x (deg*10).y	=  round(ltdeg2pix(pars( 3)/10,myscreen)); % Centre y (deg*10).fpars(1).innerRad =  ceil(ltdeg2pix(pars(4)/10,myscreen)/2); % inner diameter (deg*10).fpars(1).outerRad = floor(ltdeg2pix(pars(5)/10,myscreen)/2); % outer diameter (deg*10).fpars(1).nGrays = pars(6); % number of graz levelsfpars(1).order = pars(7); % order of moment to vary (0,1,2,3,4,5)fpars(1).magni = pars(8)/100; % modulation depth of deviations from uniform distr (0 to 100%).fpars(1).seed = pars(9);fpars(2).innerRad =  ceil(ltdeg2pix(pars(10)/10,myscreen)/2); % inner diameter (deg*10).fpars(2).outerRad = floor(ltdeg2pix(pars(11)/10,myscreen)/2); % outer diameter (deg*10).fpars(2).nGrays = pars(12); % number of graz levelsfpars(2).order = pars(13); % order of moment to vary (0,1,2,3,4,5)fpars(2).magni = pars(14)/100; % modulation depth of deviations from uniform distr (0 to 100%).fpars(2).seed = pars(15);durframes = round(myscreen.FrameRate * dur / 2.0); % stim duration in frames%%%%%%%%%%%%%%% make texturesfor ipatch = 1:length(fpars)    rescf= makeBasisFunctions(fpars(ipatch).nGrays);        ngrays = fpars(ipatch).nGrays;    graylevels = linspace(0,1,ngrays);    nframes = ngrays;    xx = [-fpars(ipatch).outerRad:fpars(ipatch).outerRad];    [XX,YY]=meshgrid(xx,xx);	% circular window. image size always even because specified by radius.	ZZ2 = XX.^2+YY.^2;	sel= find( ZZ2 > fpars(ipatch).outerRad.^2 | ZZ2 < fpars(ipatch).innerRad.^2);    tempframe = zeros(size(XX));        lowgray = 3;highgray = 255;        for iframe = 1:nframes        % uniform frame with         tempframe = round(graylevels(iframe)*(highgray-lowgray))+lowgray;        if nframes > 1        	tempframe(sel)=0; % background is gray        else            tempframe = 0;        end        ipatch        Stim{ipatch}.frames{1}{iframe} = uint8(tempframe);    end    	Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);        % make lut	nreslutentries = 3;ilut = 1;	Stim{ipatch}.luts{ilut} = zeros(256,3);	Stim{ipatch}.luts{ilut}(1,1:3) = 128;	Stim{ipatch}.luts{ilut}(2,1:3) = 255;	Stim{ipatch}.luts{ilut}(3,1:3) = 0;	Stim{ipatch}.luts{ilut}(4:256,1:3) = repmat(round([0:256/(256-nreslutentries):255])',1,3);        % make sequence	% pdf is sum uniform distribution with a basis function f(x) = P{X==x}	density = rescf(:,1) + fpars(ipatch).magni*rescf(:,fpars(ipatch).order+1);    rand('state',fpars(ipatch).seed);    Stim{ipatch}.sequence.frames = randpdf(density,1,durframes);	Stim{ipatch}.sequence.luts 		= ones(1,durframes); % only one lut        	%------- define position rect	[nx,ny]=size(Stim{ipatch}.frames{1}{1});		x1 = (round(myscreen.Xmax/2) - nx/2);	y1 = (round(myscreen.Ymax/2) - nx/2);	x2 = (round(myscreen.Xmax/2) + nx/2);	y2 = (round(myscreen.Ymax/2) + nx/2);		Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],x,y);		% The number of times you want to see the movie			Stim{ipatch}.nperiods = 1;    endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function out = randpdf(frequencies,m,n);% out = randpdf(frequencies,m,n);% frequencies is the discrete pdf. must sum to one.if round(sum(frequencies)*1e4)/1e4 ~=1 	str = sprintf('frequencies sum to %2.3f',sum(frequencies));    error(str);endncategories = length(frequencies);pmax = max(frequencies); ratios = inf*ones(size(frequencies));sel = find(frequencies);ratios(sel) = pmax./frequencies(sel);numbers = [];ndraws = 1024;while length(numbers)<m*n	urand = ceil(rand(1,ndraws)*ncategories);	test = ratios(urand).*rand(1,ndraws)';	samples = find(test<1);	numbers = [numbers urand(samples)];end% fprintf(1,'Generated %i numbers. Output: %i.\n ',length(numbers),(m*n));out = reshape(numbers(1:m*n),m,n);return;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function rescf= makeBasisFunctions(ngrays)% rescf= make_orthogonal_basis_functions(ngrays)nbasisfunctions =7;% make nonorthogonal basisv = [0:ngrays-1]';f = [];for i = 1 : nbasisfunctions;    f(1:ngrays,i)=v.^(i-1);end% orthogonalizeorthf = gram_schmidt(f);% normalized each basis function to 1;ulevel = 1/ngrays;for i =1:nbasisfunctions    mlevel(i) = max(abs(orthf(:,i)));    rescf(:,i) = orthf(:,i)/abs(mlevel(i))*ulevel;endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function Qhat = gram_schmidt(a);%   gram_schmidt   -  script implementing the step-by-step%               Gram-Schmidt algorithm.%%[ rowsA, colsA ] = size(a) ;%Qhat = a(:,1)/norm(a(:,1)); %for j = 2:colsA  Qhat(:,j) = a(:,j) - Qhat*(Qhat'*a(:,j)) ;  Qhat(:,j) = Qhat(:,j)/norm( Qhat(:,j) );endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:SCREEN('CloseAll');% iscreen = 0;% myscreen = ltScreenInitialize(iscreen);		myscreen = ltScreenInitialize;		myscreen.Dist = 57;% pars:= [ dur x y id1 od1 ng1 mom1 mag1 seed1 id2 od2 ng2 mom2 mag2 seed2]pars =   [ 50  0 0  0   10  16  2    0    99    10 100 16  2    0   999];[Stim,noise] = vflickers(pars,myscreen);vsPlayStimulus(myscreen,Stim);SCREEN('CloseAll');