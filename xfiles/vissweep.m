function Stim = vissweep(pars,myscreen)% vissweep%% pars are [tadapt tsweep twait ori x y sf100 ph tfmin tfmax lmean c idiam odiam]%% 20.7.2002 VM% The parametersp.tadapt	= pars(1)/10; % secp.tsweep	= pars(2)/10; % secp.twait	= pars(3)/10; % secp.x		= ceil(ltdeg2pix(pars(5)/10,myscreen)); % pixelp.y		= ceil(ltdeg2pix(pars(6)/10,myscreen)); % pixelp.idiam	= ceil(ltdeg2pix(pars(13)/10,myscreen)); % pixelp.odiam	= ceil(ltdeg2pix(pars(14)/10,myscreen)); % pixelgrat.ori		= pars(4)*pi/180; % radiansgrat.sf		= pars(7)/100; % c/deggrat.phase 	= pars(8)*pi/180; % radiansgrat.tfmin	= pars(9)/10; % c/secgrat.tfmax	= pars(10)/10; % c/secgrat.lmean	= pars(11)/100*255; % uint8grat.c		= pars(12)/100; % contrastnreslutentries = 4;% The 4. entry in the lut is the mean luminance of the stimulus% check that diams are reasonableif p.idiam > p.odiam	p.odiam = p.idiam;end%-------------------------------------% MAKE THE FRAME%-------------------------------------% The radius of the gratingp.innerRad = round(p.idiam/2);% The radius of the adapting diskp.outerRad = round(p.odiam/2);nx = 2*p.outerRad;ny = 2*p.outerRad;% Make a grid of x and y[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);% The sf of the grating in cycles/pixelDegPerCycle = 1/grat.sf;PixPerCycle = ltdeg2pix(DegPerCycle,myscreen);grat.psf = 1/PixPerCycle;% Make grid of angular frequency% the signs are taken from visdriftsin100angfreq = -2*pi*grat.psf*(cos(grat.ori).*xx+sin(grat.ori).*yy ) + grat.phase;% in radians% MAKE SURE THAT SinPars.phase is in radians, or you'll get weird behaviorangles = angle(exp(sqrt(-1)*angfreq)) + pi;% now it is between 0 and 2*piimg = round(angles* (255-nreslutentries)/(2*pi)) + nreslutentries;% now it is between nreslutentries and 255if any(img<nreslutentries | img>255)	error('img is out of range');endgrtframe = uint8(img);% Create the adaptation annulusdd = sqrt(xx.^2+yy.^2);	% distance matrixapts = find( dd <= p.outerRad  & dd > p.innerRad );grtframe(apts) = 3; % The fourth entry in the lut% Create what is outside the annulusdd = sqrt(xx.^2+yy.^2);	% distance matrixwpts = find( dd > p.outerRad );grtframe(wpts) = 0; % The first entry in the lut% That's itStim.frames{1}{1} = grtframe;Stim = ltMakeOffScreenWindows(myscreen,Stim,1);%-------------------------------------% MAKE THE LUTS%-------------------------------------% The number of frames in the upsweepnupsweep = ceil(p.tsweep/2*myscreen.FrameRate);% The times corresponding to each frame in the up sweeptupframe = (0:nupsweep - 1)/myscreen.FrameRate;% The total number of frames (first increase, than decrease of tf)nsweep = 2*nupsweep - 1;% The times corresponding to each frame in the entire sweeptframe = (0:nsweep - 1)/myscreen.FrameRate;% The time-dependent temporal frequency of the gratingif grat.tfmax < grat.tfmin   error('tfmax has to be larger than the tfmin !!')'endlog10timetfup = (log10(grat.tfmax) - log10(grat.tfmin))/((nupsweep-1)/myscreen.FrameRate)*tupframe + log10(grat.tfmin);timetfup = 10.^(log10timetfup);% The temporal phase of the cosine in the luttimephase = [];timephase(1) = 0;% The up sweepfor iframe = 2:nupsweep   timephase(iframe) = timephase(iframe-1) + 2*pi*timetfup(iframe-1)/myscreen.FrameRate;end% The down sweeptimetfdw = fliplr(timetfup(1:end-1));for iframe = nupsweep+1:nsweep   timephase(iframe) = timephase(iframe-1) + 2*pi*timetfdw(iframe-nupsweep)/myscreen.FrameRate;end% The spatial phaselutk = 2*pi/(256 - nreslutentries);lutxx = (nreslutentries:255)-nreslutentries;spacephase = lutk*lutxx;% Fill up the lutsthislut = zeros(256,3);reslutentries = [128 128 128; 255 255 255; 0 0 0; grat.lmean grat.lmean grat.lmean];% The adaptation stimulusnadapt = ceil(p.tadapt*myscreen.FrameRate);for iframe = 1:nadapt   mylut = ones(1,252)*grat.lmean;   thislut(1:4,:) = reslutentries;   thislut(5:end,:) = [mylut' mylut' mylut'];   Stim.luts{iframe} = thislut;end% The sweepfor iframe = 1:nsweep   lutphase = spacephase + timephase(iframe);   mylut = min(255,grat.lmean + grat.lmean*grat.c*sin(lutphase));   mylut = max(0,mylut);   thislut(1:4,:) = reslutentries;   thislut(5:end,:) = [mylut' mylut' mylut'];   Stim.luts{iframe+nadapt} = thislut;end% The adaptation stimulus againnwait = ceil(p.twait*myscreen.FrameRate);for iframe = 1:nwait   mylut = ones(1,252)*grat.lmean;   thislut(1:4,:) = reslutentries;   thislut(5:end,:) = [mylut' mylut' mylut'];   Stim.luts{iframe+nadapt+nsweep} = thislut;end% The sequence of frames and lutsnframes = length(Stim.luts);Stim.sequence.frames = ones(1,nframes);Stim.sequence.luts = 1:nframes;% The number of times you want to see this beautifull stimulusStim.nperiods = 1;% The position of the stimulusx1 = round(myscreen.Xmax/2 - p.odiam/2);y1 = round(myscreen.Ymax/2 - p.odiam/2);x2 = round(myscreen.Xmax/2 + p.odiam/2);y2 = round(myscreen.Ymax/2 + p.odiam/2);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);return% Code to test the function% The screen%myscreen = vsMakeMyscreen;% The parameterstadapt = 10;tsweep = 150;twait = 5;ori = 180;x = -59;y = 79;sf100 = 20;ph = 0;tfmin = 5;tfmax = 400;lmean = 0.5;c = 10;idiam = 100;odiam = 10;pars = [tadapt tsweep twait ori x y sf100 ph tfmin tfmax lmean c idiam odiam];myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);Stim = vissweep(pars,myscreen);vsPlayStimulus(myscreen,Stim,'norush');ltClearStimulus(Stim,'nowarnings');dur = 100;tf = 1;sf100 = 20;c = 100;ori = 45;x = -59;y = 79;Stim1 = visdriftsin100([dur tf sf100 c ori x y   8],myscreen);vsPlayStimulus(myscreen,Stim1,'norush');	ltClearStimulus(Stim1,'nowarnings'); SCREEN('CloseAll');	