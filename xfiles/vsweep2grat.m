function Stim = vsweep2grat(pars,myscreen)% vsweep2grat%% pars are [tadapt tsweep twait idiam odiam x y ctfmin stfmin ctfmax stfmax %           orictr orisrd sf100c sf100s phctr phsrd lctr lsrd cctr csrd]%% 7-2002 VM% 7-2003 corrected rounding bug that caused frame size mismatched with stimulus.%        renamed to vsweep2grat% The parameters common to disk and annulusp.tadapt	= pars(1)/10; % secp.tsweep	= pars(2)/10; % secp.twait	= pars(3)/10; % secp.idiam	= ceil(ltdeg2pix(pars(4)/10,myscreen)); % pixelp.odiam	= ceil(ltdeg2pix(pars(5)/10,myscreen)); % pixelp.x		= ceil(ltdeg2pix(pars(6)/10,myscreen)); % pixelp.y		= ceil(ltdeg2pix(pars(7)/10,myscreen)); % pixel% Parameters of the center diskctr.tfmin	= pars(8)/10; % c/secctr.tfmax	= pars(10)/10; % c/secctr.ori		= pars(12)*pi/180; % radiansctr.sf		= pars(14)/100; % c/degctr.phase 	= pars(16)*pi/180; % radiansctr.lmean	= pars(18)/100*255; % uint8ctr.c		= pars(20)/100; % contrast% Parameters of the surround annulussrd.tfmin	= pars(9)/10; % c/secsrd.tfmax	= pars(11)/10; % c/secsrd.ori		= pars(13)*pi/180; % radianssrd.sf		= pars(15)/100; % c/degsrd.phase 	= pars(17)*pi/180; % radianssrd.lmean	= pars(19)/100*255; % uint8srd.c		= pars(21)/100; % contrastnreslutentries = 3; % check that diams are reasonableif p.idiam > p.odiam	p.odiam = p.idiam;end % check that tfs are reasonableif ctr.tfmax < ctr.tfmin   error('ctfmax has to be larger than ctfmin !!')'endif srd.tfmax < srd.tfmin   error('stfmax has to be larger than stfmin !!')'end%-------------------------------------% MAKE THE FRAMES%-------------------------------------% The radius of the gratingp.innerRad = round(p.idiam/2);% The radius of the adapting diskp.outerRad = round(p.odiam/2);% Make a grid of x and ynx = 2*p.outerRad;ny = 2*p.outerRad;[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);% The points in the center vs surrounddd = sqrt(xx.^2+yy.^2);	% distance matrixctrpts = find( dd <= p.innerRad );srdpts = find( dd > p.innerRad & dd <= p.outerRad );otherpts = setdiff(1:nx*ny, [ctrpts; srdpts]);%--- THE FRAME WITH GRATING ---%% The sfs of the grating in cycles/pixelif ctr.sf > 0	DegPerCycleCtr = 1/ctr.sf;	PixPerCycleCtr = ltdeg2pix(DegPerCycleCtr,myscreen);	ctr.psf = 1/PixPerCycleCtr;else	ctr.psf = 0;endif srd.sf > 0	DegPerCycleSrd = 1/srd.sf;	PixPerCycleSrd = ltdeg2pix(DegPerCycleSrd,myscreen);	srd.psf = 1/PixPerCycleSrd;else	srd.psf = 0;end% Make grids of angular frequency% the signs are taken from visdriftsin100AngFreq  = zeros([nx ny]);AngFreq(ctrpts) = -2*pi*ctr.psf*(cos(ctr.ori)*xx(ctrpts)+sin(ctr.ori)*yy(ctrpts)) + ctr.phase;AngFreq(srdpts) = -2*pi*srd.psf*(cos(srd.ori)*xx(srdpts)+sin(srd.ori)*yy(srdpts)) + srd.phase;% in radians% MAKE SURE THAT phase is in radians, or you'll get weird behaviorAmpli = (angle(exp(sqrt(-1)*AngFreq)) + pi)/(2*pi);% now it is between 0 and 1% One half of the values for the center, the other half for the surroundnlutentries = 256 - nreslutentries;nctr = round(nlutentries/2);nsrd = nlutentries - nctr;img = zeros([nx ny]);img(ctrpts) = Ampli(ctrpts)*(nctr-1) + nreslutentries; % From nreslutentries to nreslutentries+nctr-1 img(srdpts) = Ampli(srdpts)*(nsrd-1) + nreslutentries + nctr;% From nreslutentries+nctr to nreslutentries+nctr+nsrd-1if any(img<nreslutentries | img>255)	error('img is out of range');end% That's itStim.frames{1}{1} = zeros([nx ny]);Stim.frames{1}{1} = uint8(img);Stim.frames{1}{1}(otherpts) = 0; % The first entry in the lut%--- THE FRAME WITHOUT GRATING ---%Stim.frames{1}{2} = zeros([nx ny]);Stim.frames{1}{2}(ctrpts) = 3; % The beginning if the first part of the lutStim.frames{1}{2}(srdpts) = 3+nctr; % The beginning of the second part of the lutStim = ltMakeOffScreenWindows(myscreen,Stim,1); %-------------------------------------% MAKE THE LUTS%-------------------------------------% The number of frames in the upsweepnupsweep = ceil(p.tsweep/2*myscreen.FrameRate);% The times corresponding to each frame in the up sweeptupframe = (0:nupsweep - 1)/myscreen.FrameRate;% The total number of frames (first increase, than decrease of tf)nsweep = max(0,2*nupsweep - 1);% The times corresponding to each frame in the entire sweeptframe = (0:nsweep - 1)/myscreen.FrameRate;% The time-dependent temporal frequency of the gratinglog10timetfupCtr = (log10(ctr.tfmax) - log10(ctr.tfmin))/((nupsweep-1)/myscreen.FrameRate)*tupframe + log10(ctr.tfmin);timetfupCtr = 10.^(log10timetfupCtr);log10timetfupSrd = (log10(srd.tfmax) - log10(srd.tfmin))/((nupsweep-1)/myscreen.FrameRate)*tupframe + log10(srd.tfmin);timetfupSrd = 10.^(log10timetfupSrd);% The temporal phase of the cosine in the luttimephaseCtr = [];timephaseCtr(1) = 0;timephaseSrd = [];timephaseSrd(1) = 0;% The up sweepfor iframe = 2:nupsweep   timephaseCtr(iframe) = timephaseCtr(iframe-1) + 2*pi*timetfupCtr(iframe-1)/myscreen.FrameRate;   timephaseSrd(iframe) = timephaseSrd(iframe-1) + 2*pi*timetfupSrd(iframe-1)/myscreen.FrameRate;end% The down sweeptimetfdwCtr = fliplr(timetfupCtr(1:end-1));timetfdwSrd = fliplr(timetfupSrd(1:end-1));for iframe = nupsweep+1:nsweep   timephaseCtr(iframe) = timephaseCtr(iframe-1) + 2*pi*timetfdwCtr(iframe-nupsweep)/myscreen.FrameRate;   timephaseSrd(iframe) = timephaseSrd(iframe-1) + 2*pi*timetfdwSrd(iframe-nupsweep)/myscreen.FrameRate;end% The spatial phase of the center disklutkCtr = 2*pi/nctr;lutxxCtr = (nreslutentries:nreslutentries+nctr-1)-nreslutentries;spacephaseCtr = lutkCtr*lutxxCtr;% The spatial phase of the surround annuluslutkSrd = 2*pi/nsrd;lutxxSrd = (nreslutentries+nctr:nreslutentries+nctr+nsrd-1)-nreslutentries-nctr;spacephaseSrd = lutkSrd*lutxxSrd;% Fill up the lutsreslutentries = [128 128 128; 255 255 255; 0 0 0];% The adaptation stimulusthislut = zeros(256,3);nadapt = ceil(p.tadapt*myscreen.FrameRate);for iframe = 1:nadapt   thislut(1:3,:) = reslutentries;   thislut(4:4+nctr-1,:) = ctr.lmean;   thislut(4+nctr:end,:) = srd.lmean;   Stim.luts{iframe} = thislut;end% The sweepthislut = zeros(256,3);for iframe = 1:nsweep   % The reserved lut entries   thislut(1:3,:) = reslutentries;      % The center entries   lutphaseCtr = spacephaseCtr + timephaseCtr(iframe);   mylutCtr = min(255,ctr.lmean + ctr.lmean*ctr.c*sin(lutphaseCtr));   mylutCtr = max(0,mylutCtr);      % The surround entries   lutphaseSrd = spacephaseSrd + timephaseSrd(iframe);   mylutSrd = min(255,srd.lmean + srd.lmean*srd.c*sin(lutphaseSrd));   mylutSrd = max(0,mylutSrd);      % Put all together   thislut(nreslutentries+1:nreslutentries+nctr,:) = [mylutCtr' mylutCtr' mylutCtr'];   thislut(nreslutentries+nctr+1:nreslutentries+nctr+nsrd,:) = [mylutSrd' mylutSrd' mylutSrd'];   Stim.luts{iframe+nadapt} = thislut;end% The adaptation stimulus againthislut = zeros(256,3);nwait = ceil(p.twait*myscreen.FrameRate);for iframe = 1:nwait   thislut(1:3,:) = reslutentries;   thislut(4:4+nctr-1,:) = ctr.lmean;   thislut(4+nctr:end,:) = srd.lmean;   Stim.luts{iframe+nadapt+nsweep} = thislut;end% The sequence of frames and lutsnframes = length(Stim.luts);Stim.sequence.frames = ones(1,nframes);Stim.sequence.frames(1:nadapt) = 2;Stim.sequence.frames(nadapt+nsweep+1:end) = 2;%Stim.sequence.frames(1:nadapt+1) = 2;%Stim.sequence.frames(nadapt+nsweep+2:end) = 2;Stim.sequence.luts = 1:nframes;% The number of times you want to see this beautifull stimulusStim.nperiods = 1;% The position of the stimulusx1 = round(myscreen.Xmax/2) - round(p.odiam/2);y1 = round(myscreen.Ymax/2) - round(p.odiam/2);x2 = round(myscreen.Xmax/2) + round(p.odiam/2);y2 = round(myscreen.Ymax/2) + round(p.odiam/2);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);return% Code to test the function% The screen%myscreen = vsMakeMyscreen;myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);% pars are [tadapt tsweep twait idiam odiam x y tfmin tfmax %           orictr orisrd sf100c sf100s phctr phsrd lctr lsrd cctr csrd]% The parameterstadapt = 20;tsweep = 100;twait = 10;idiam = 70;odiam = 150;x = -46;y = 50;ctfmin = 5;stfmin = 5;ctfmax = 400;stfmax = 400;orictr = 0;orisrd = 0;sf100c = 0;sf100s = 0;phctr = 0;phsrd = 0;lctr = 50;lsrd = 100;cctr = 50;csrd = 0;pars = [tadapt tsweep twait idiam odiam x y ctfmin stfmin ctfmax stfmax orictr orisrd sf100c sf100s phctr phsrd lctr lsrd cctr csrd];Stim = vsweep2grat(pars,myscreen);vsPlayStimulus(myscreen,Stim,'norush');ltClearStimulus(Stim,'nowarnings');dur = 100;tf = 1;sf100 = 20;c = 100;ori = 45;x = -59;y = 79;Stim1 = visdriftsin100([dur tf sf100 c ori x y   8],myscreen);vsPlayStimulus(myscreen,Stim1,'norush');	ltClearStimulus(Stim1,'nowarnings'); SCREEN('CloseAll');	 