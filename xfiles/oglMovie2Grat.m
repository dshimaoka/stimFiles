function Stim = oglMovie2Grat(pars,myscreen)% Two gratings a` la OpenGL, precomputes all textures including plaids % % Stim =  oglMovie2Grat(pars,myscreen)% where pars is% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb2 x2 y2 flick2 sqwv2 duty2 shape2 ]%% sqwv = 1 for square waves, 0 for sin waves duty is the duty cycle in% percent (normal is 100) shape determines whether the window is an annulus% (shape = 0) or a rectangle (shape = 1) dima and dimb are inner and outer% diameter (for annuli) or dimensions x and y (for rectangles)%% based on vmovie2gratinterok.x%% based on 2004-11 Matteo Carandini% LB 2008-03-06 added some of the ogl capabilities (orientation)%%% Durationdur 	= pars(1)/10; %= dur; % Stim. durationipar = 1;for igrat = 1:2	sinpars(igrat).tfreq	 	= pars(ipar+1)/10; 		sinpars(igrat).sfreq  		= pars(ipar+2)/100; 			sinpars(igrat).tempphase  	= pars(ipar+3) * (pi/180); 			sinpars(igrat).spatphase  	= pars(ipar+4) * (pi/180); 			sinpars(igrat).contrast 	= pars(ipar+5)/100; 	sinpars(igrat).orientation 	= pars(ipar+6);% * (pi/180); orientation is in deg for ogl	sinpars(igrat).dima			= ceil (ltdeg2pix(pars(ipar+7)/10,myscreen)); % inner diameter (deg/10).	sinpars(igrat).dimb			= floor(ltdeg2pix(pars(ipar+8)/10,myscreen)); % outer diameter (deg/10).	sinpars(igrat).x	 		= ltdeg2pix(pars(ipar+ 9)/10,myscreen); % Centre x (deg/10).	sinpars(igrat).y		 	= ltdeg2pix(pars(ipar+10)/10,myscreen); % Centre y (deg/10).	sinpars(igrat).flicker 		= pars(ipar+11);	sinpars(igrat).sqwv 		= pars(ipar+12);	sinpars(igrat).duty  		= pars(ipar+13)/100;	sinpars(igrat).shape  		= pars(ipar+14); % 0 = circle; 1 = rect	ipar = 15;endnframes = round(myscreen.FrameRate * dur); 	for igrat = 1:2		t = 0.001; % threshold	% cos( d/100*pi/2 )^n = t	if sinpars(igrat).duty<1		alpha = log(t)/log(cos( sinpars(igrat).duty*pi/2 ));	else		alpha = 1;	end		% Spatial frequency in cycles/pixel	PixPerCycle = ltdeg2pix(1/sinpars(igrat).sfreq,myscreen);	sinpars(igrat).frequency = 1/PixPerCycle; % sf in cycles/pix		switch sinpars(igrat).shape	case 0 		% it is an annulus		maxrad = max(1, sinpars(igrat).dimb/2);		nx = ceil(2*maxrad);		ny = ceil(2*maxrad);		case 1		% it is a rectangle		nx = max(1,sinpars(igrat).dima);		ny = max(1,sinpars(igrat).dimb);	end		% Make a grid of x and y	[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);		% The spatial phase of the stimulus	% the minus sign below is for consistency with the orientation of other stimuli    ori = 0; % LB 080306: sinpars(igrat).orientation will be used later	angfreq{igrat} = -2*pi* sinpars(igrat).frequency * (...		cos(ori).*xx + ...		sin(ori).*yy ) + sinpars(igrat).spatphase;	% in radians		switch sinpars(igrat).shape	case 0 		% an annular window		dd = sqrt(xx.^2+yy.^2);		win{igrat} = double(dd >= sinpars(igrat).dima/2 & dd <= sinpars(igrat).dimb/2);	case 1		% no window is needed to make a rectangle		win{igrat} = 1;	end		% The temporal phase of the response		periods(igrat) = round(myscreen.FrameRate / sinpars(igrat).tfreq);	tphase{igrat} = 2*pi*[0:(periods(igrat)-1)]/periods(igrat) + sinpars(igrat).tempphase;	fprintf(1,'Frequency %d is %2.2f rather than %2.0f Hz\n', ...		igrat, myscreen.FrameRate/periods(igrat) /2, sinpars(igrat).tfreq /2);			% Make movies	fprintf(1,' Frames for grating %d...', igrat);	if sinpars(igrat).flicker		%contrast = sinpars(igrat).contrast * sin(tphase{igrat});		contrast = 1 * sin(tphase{igrat}); % contrast will be set by alpha blending			spatialstim = sin(angfreq{igrat});			spatialstim = sign(spatialstim).*abs(spatialstim).^alpha;		if sinpars(igrat).sqwv			spatialstim = (spatialstim>0.01)-(spatialstim<-0.01);		end		for iframe = 1:periods(igrat)			grat{igrat,iframe} = contrast(iframe) .* spatialstim .* win{igrat};		end			else		for iframe = 1:periods(igrat)			spatialstim = sin( angfreq{igrat} + tphase{igrat}(iframe));			spatialstim = sign(spatialstim).*abs(spatialstim).^alpha;			if sinpars(igrat).sqwv				spatialstim = (spatialstim>0.01)-(spatialstim<-0.01);			end				grat{igrat,iframe} = sinpars(igrat).contrast * spatialstim  .* win{igrat};		end	end	for iframe = 1:periods(igrat)		Stim{igrat}.frames{1}{iframe} = uint8( grat{igrat,iframe}*126 + 129 );	end		% Make the lookup table	Stim{igrat}.luts{1} = repmat([128 255 0 1:253]',1,3);		% Make sequence	Stim{igrat}.sequence.frames = 1+mod(1:nframes,periods(igrat));	Stim{igrat}.sequence.luts = ones(1,nframes);		fprintf(1,'Putting them offscreen...');	Stim{igrat} = ltMakeOffScreenWindows(myscreen,Stim{igrat},1);		fprintf(1,'done\n');		% The position vector	x = round(sinpars(igrat).x + myscreen.Xmax/2 - nx/2);	y = round(sinpars(igrat).y + myscreen.Ymax/2 - ny/2);	Stim{igrat}.position(1,:) = [x y x+nx y+ny];		Stim{igrat}.nperiods = 1;	    % Laura 080306    Stim{igrat}.ori = sinpars(igrat).orientation*ones(1,nframes);    Stim{igrat}.globalAlpha = sinpars(igrat).contrast*ones(1,nframes);    Stim{igrat}.srcRect = cell(1,nframes);endreturn%% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen);% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb x2 y2 flick2 sqwv2 duty2 shape2]% ltClearStimulus(Stim,'nowarnings'); dur = 40;tf = [ 30 30 ];sf = [ 100 100 ];tph = [ 180 180 ];sph = [ 90 90 ];c = [50 50];ori = [60 150];dima = [0 100];dimb = [100 100];x = [0 0];y = [0 0];flick = [ 1 1  ];sqwv = [ 1 1 ];duty = [ 50 50 ];shape = [ 0 1 ];dur = 40;tf = [ 30 30 ];sf = [ 10 10 ];tph = [ 0 0 ];sph = [ 0 0 ];c = [50 50];ori = [90 0];dima = [0 0];dimb = [300 300];x = [0 0];y = [0 0];flick = [ 1 1  ];sqwv = [ 0 0 ];duty = [100 100];shape = [ 0 0];pars = [  dur ...    tf(1) sf(1) tph(1) sph(1) c(1) ori(1) dima(1) dimb(1) x(1) y(1) flick(1) sqwv(1) duty(1) shape(1)...    tf(2) sf(2) tph(2) sph(2) c(2) ori(2) dima(2) dimb(2) x(2) y(2) flick(2) sqwv(2) duty(2) shape(2)];Stim = oglMovie2Grat(pars,myscreen);Stim = vsLoadTextures(myscreen, Stim);%m = vsPlayStimulusLB(myscreen,Stim);	vsPlayStimulus(myscreen, Stim);ltClearStimulus(Stim,'nowarnings'); ltClearLoadedTextures;Screen('CloseAll');