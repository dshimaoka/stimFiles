function Stim = vmovie2sequentialGratingMD(pars,myscreen)% vmovie2sequentialGrating code for vmovie2sequentialGrating.x% % Stim =  vmovie2sequentialGrating(pars,myscreen)%%% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb2 x2 y2 flick2 sqwv2 duty2 shape2 ]%% sqwv = 1 for square waves, 0 for sin waves% duty is the duty cycle in percent% shape determines whether the window is an annulus (shape = 0) or a rectangle (shape = 1)% dima and dimb are inner and outer diameter (for annuli) or dimensions x and y (for rectangles)%% 2006-03 Andrea Benucci% 2006-07 MC fixed problem at the end (there is no imagePtr in DEMO mode)% 2007-03 MC extensively updated, fixed bug that was occurring when stimulus sizes differed% Durationdur 	= pars(1)/10; %= dur; % Stim. durationswitchTime = pars(2)/10; % time stimulus switchesipar = 2;for igrat = 1:2	sinpars(igrat).tfreq	 	= pars(ipar+1)/10; 		sinpars(igrat).sfreq  		= pars(ipar+2)/100; 			sinpars(igrat).tempphase  	= pars(ipar+3) * (pi/180); 			sinpars(igrat).spatphase  	= pars(ipar+4) * (pi/180); 			sinpars(igrat).contrast 	= pars(ipar+5)/100; 	sinpars(igrat).orientation 	= pars(ipar+6) * (pi/180); 	sinpars(igrat).dima			= ceil (ltdeg2pix(pars(ipar+7)/10,myscreen)); % inner diameter (deg/10).	sinpars(igrat).dimb			= floor(ltdeg2pix(pars(ipar+8)/10,myscreen)); % outer diameter (deg/10).	sinpars(igrat).x	 		= ltdeg2pix(pars(ipar+ 9)/10,myscreen); % Centre x (deg/10).	sinpars(igrat).y		 	= ltdeg2pix(pars(ipar+10)/10,myscreen); % Centre y (deg/10).	sinpars(igrat).flicker 		= pars(ipar+11);	sinpars(igrat).sqwv 		= pars(ipar+12);	sinpars(igrat).duty  		= pars(ipar+13)/100;	sinpars(igrat).shape  		= pars(ipar+14); % 0 = circle; 1 = rect	sinpars(igrat).blur         = ceil (ltdeg2pix(pars(ipar+15)/10,myscreen)); %window blur diameter (deg/10)    ipar = 17;endnframes   = round(myscreen.FrameRate * dur);frmSwitch = round(myscreen.FrameRate * switchTime);if frmSwitch>nframes	frmSwitch = nframes;endfor igrat = 1:2		t = 0.001; % threshold	% cos( d/100*pi/2 )^n = t	if sinpars(igrat).duty<1		alpha = log(t)/log(cos( sinpars(igrat).duty*pi/2 )); %/2 if interleaving	else		alpha = 1;	end		% Spatial frequency in cycles/pixel	PixPerCycle = ltdeg2pix(1/sinpars(igrat).sfreq,myscreen);	sinpars(igrat).frequency = 1/PixPerCycle; % sf in cycles/pix		switch sinpars(igrat).shape	case 0 		% it is an annulus		maxrad = max(1, sinpars(igrat).dimb/2);		nx = ceil(2*maxrad);		ny = ceil(2*maxrad);		case 1		% it is a rectangle		nx = max(1,sinpars(igrat).dima);		ny = max(1,sinpars(igrat).dimb);	end		% Make a grid of x and y	[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);		% The spatial phase of the stimulus	% the minus sign below is for consistency with the orientation of other stimuli	angfreq{igrat} = -2*pi* sinpars(igrat).frequency * (...		cos(sinpars(igrat).orientation).*xx + ...		sin(sinpars(igrat).orientation).*yy ) + sinpars(igrat).spatphase;	% in radians		switch sinpars(igrat).shape	case 0         % an annular window        dd = sqrt(xx.^2+yy.^2);        win{igrat} = double(dd >= sinpars(igrat).dima/2 & dd <= sinpars(igrat).dimb/2);        win{igrat} = win{igrat} .* exp(-dd.^2/sinpars(igrat).blur.^2);                case 1		% no window is needed to make a rectangle		win{igrat} = 1;	end		% The temporal phase of the response		periods(igrat) = round(myscreen.FrameRate / sinpars(igrat).tfreq);	tphase{igrat} = 2*pi*[0:(periods(igrat)-1)]/periods(igrat) + sinpars(igrat).tempphase;	fprintf(1,'Frequency %d is %2.2f rather than %2.0f Hz\n', ...		igrat, myscreen.FrameRate/periods(igrat) /2, sinpars(igrat).tfreq /2);			% Make movies	fprintf(1,' Frames for grating %d...', igrat);	if sinpars(igrat).flicker		contrast = sinpars(igrat).contrast * sin(tphase{igrat});			spatialstim = sin(angfreq{igrat});			spatialstim = sign(spatialstim).*abs(spatialstim).^alpha;		if sinpars(igrat).sqwv			spatialstim = (spatialstim>0.01)-(spatialstim<-0.01);		end		for iframe = 1:periods(igrat)			grat{igrat,iframe} = contrast(iframe) .* spatialstim .* win{igrat};		end				else		for iframe = 1:periods(igrat)			spatialstim = sin( angfreq{igrat} + tphase{igrat}(iframe));			spatialstim = sign(spatialstim).*abs(spatialstim).^alpha;            %             mask = exp(-xx/5^2-yy/5^2);%             spatialstim = spatialstim .* mask;            			if sinpars(igrat).sqwv				spatialstim = (spatialstim>0.01)-(spatialstim<-0.01);			end				grat{igrat,iframe} = sinpars(igrat).contrast * spatialstim  .* win{igrat};		end	end	for iframe = 1:periods(igrat)		Stim{igrat}.frames{1}{iframe} = uint8( grat{igrat,iframe}*126 + 129 );	end		% Make the lookup table	Stim{igrat}.luts{1} = repmat([128 255 0 1:253]',1,3);		% Make sequence	Stim{igrat}.sequence.frames = 1+mod(1:nframes,periods(igrat));    Stim{igrat}.sequence.luts = ones(1,nframes);	% 	fprintf(1,'Putting them offscreen...');% 	Stim{igrat} = ltMakeOffScreenWindows(myscreen,Stim{igrat},1);		fprintf(1,'done\n');		% The position vector	x = round(sinpars(igrat).x + myscreen.Xmax/2 - nx/2);	y = round(sinpars(igrat).y + myscreen.Ymax/2 - ny/2);	Stim{igrat}.position(1,:) = [x y x+nx y+ny];	Stim{igrat}.nperiods = 1;	endif Stim{1}.position-Stim{2}.position    warning('Positions of first stimulus and of second stimulus should be the same!!');    % Stim{1} = Stim{2}; %  this leads to crashes!!endfprintf(1,'Concatenating Stim structure\n');SingleStim = Stim{1};% dums = {}; % dums.sequence.frames = [];% dums.luts     = Stim{1}.luts; % dums.position = Stim{1}.position;% if isfield(Stim{1},'imagePtr')%     dums.imagePtr = Stim{1}.imagePtr; % end% dums.nperiods = 1;% dums.sequence.frames(1:frmSwitch) = Stim{1}.sequence.frames(1:frmSwitch);% dums.sequence.frames(frmSwitch+1:nframes) = Stim{2}.sequence.frames(frmSwitch+1:nframes) + periods(1);% dums.sequence.luts = Stim{1}.sequence.luts;% for istim = 1:periods(1),dums.frames{1}{istim}              =   Stim{1}.frames{1}{istim};end % for istim = 1:periods(2),dums.frames{1}{periods(1)+istim}   =   Stim{2}.frames{1}{istim};end% if isfield(Stim{1},'imagePtr')%     for istim = 1:periods(1),dums.imagePtr{1}(istim)            = Stim{1}.imagePtr{1}(istim);end%     for istim = 1:periods(2),dums.imagePtr{1}(periods(1)+istim) = Stim{2}.imagePtr{1}(istim);end% end% Stim = dums;nluts1 = length(Stim{1}.luts);nframes1 = length(Stim{1}.frames{1});SingleStim.luts = [Stim{1}.luts; Stim{2}.luts];SingleStim.sequence.luts   = [ Stim{1}.sequence.luts(1:frmSwitch),     nluts1+Stim{2}.sequence.luts   ];SingleStim.sequence.frames = [ Stim{1}.sequence.frames(1:frmSwitch), nframes1+Stim{2}.sequence.frames ];for iframe = 1:periods(1),SingleStim.frames{1}{iframe}              =   Stim{1}.frames{1}{iframe};end for iframe = 1:periods(2),SingleStim.frames{1}{periods(1)+iframe}   =   Stim{2}.frames{1}{iframe};endStim = SingleStim;return%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 31;ltLoadCalibration(myscreen,3);% [  dur swT...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb x2 y2 flick2 sqwv2 duty2 shape2]if exist('Stim','var'), ltClearStimulus(Stim,'nowarnings'); enddur = 40;swT = 50;tf = [ 20 50 ];sf = [ 40 40 ];tph = [ 180 180 ];sph = [ 90 90 ];c = [90 30];ori = [90 0];dima = [0 0];dimb = [100 100];x = [0 0];y = [0 0];flick = [ 1 0 ];sqwv = [ 0 0 ];duty = [ 100 100 ];shape = [ 0 0 ];dur = 40;swT = 20;tf = [ 40 50 ];sf = [ 10 50 ];tph = [ 0 0 ];sph = [ 0 0 ];c = [50 50];ori = [90 90];dima = [130 50];dimb = [100 100];x = [0 -30];y = [0 50];flick = [ 0 1 ];sqwv = [ 0 1 ];duty = [ 100 60 ];shape = [ 0 1 ];pars = [  dur swT...    tf(1) sf(1) tph(1) sph(1) c(1) ori(1) dima(1) dimb(1) x(1) y(1) flick(1) sqwv(1) duty(1) shape(1)...    tf(2) sf(2) tph(2) sph(2) c(2) ori(2) dima(2) dimb(2) x(2) y(2) flick(2) sqwv(2) duty(2) shape(2)];Stim = vmovie2sequentialGratingMD(pars,myscreen);Stim = vsLoadTextures(myscreen, Stim, 1);vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');