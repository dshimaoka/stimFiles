function oglStim = oglStaticPrePostB(pars,myscreen,flagNoTextures)% Two gratings, in disks or annuli or rectangles static presentation with% periods of blank before and after.%% oglStim =  oglStaticPrePostB(pars,myscreen)% where pars is% [  durpre durstim durpost ...%    sf1 sph1 c1 ori1 dima1 dimb1 x1 y1 sqwv1 shape1...%    sf2 sph2 c2 ori2 dima2 dimb2 x2 y2 sqwv2 shape2 ]%% sqwv = 1 for square waves, 0 for sin waves% shape = 0 for annulus, 1 for rectangle% dima, dimb are inner and outer diameters (for annuli) or dimensions x and y (for rectangles)%% oglStim = oglStatic(pars,myscreen,flagNoTextures) lets you specify% whether you don't want textures (DEFAULT: flagNoTextures = false).%% History:% vmovie2gratinterok.x (old fashioned interleaved stimulus)% oglMovie2Grat.x (OpenGL version needing lots of textures)% oglMovie2GratLin.x (with alpha blending but bug in drifting gratings)% oglTwoGratings fixed bug, done away with fake interleaving% oglStatic static spatial pattern presented for duration% oglStaticPrePostB static spatial pattern presented for duration with% blanks before and after the static presentation%% ND 2010-10-28%% dummies for debugging% pars = [ 20 30 10 ...%     5 0 100 80 0 200 0 0 0 ...%     5 0   0 80 0 200 0 0 0 ];%% myscreen = ltScreenInitialize;%% parse the parametersif nargin < 3    flagNoTextures = false;enddurpre      = pars(1)/10; % s, duration of pre blankdurstim 	= pars(2)/10; % s, duration of stimdurpost     = pars(3)/10; % s, duration of post blankipar = 3;sinpars = [struct; struct];for igrat = 1:2    sinpars(igrat).sfreq  		= pars(ipar+1)/100;             % cpd    sinpars(igrat).spatphase  	= pars(ipar+2) * (pi/180);      % radians    sinpars(igrat).contrast 	= pars(ipar+3)/100;             % percent    sinpars(igrat).orientation 	= pars(ipar+4);                 % deg    sinpars(igrat).dima			= ceil (ltdeg2pix(pars(ipar+5)/10,myscreen)); % deg    sinpars(igrat).dimb			= floor(ltdeg2pix(pars(ipar+6)/10,myscreen)); % deg    sinpars(igrat).x	 		= ltdeg2pix(pars(ipar+ 7)/10,myscreen); % deg    sinpars(igrat).y		 	= ltdeg2pix(pars(ipar+8)/10,myscreen); % deg    sinpars(igrat).sqwv 		= pars(ipar+9);    sinpars(igrat).shape  		= pars(ipar+10); % 0 = circle; 1 = rect    ipar = 13;endnframes_pre  = round(myscreen.FrameRate * durpre);nframes_stim = round(myscreen.FrameRate * durstim);nframes_post = round(myscreen.FrameRate * durpost);dur = durpre+durstim+durpost;nframes = nframes_pre+nframes_stim+nframes_post;%% Fundamental fieldsoglStim = oglStimNew(); % preallocate so you have correct order of parametersoglStim.Generation = 3; % 3rd gen (1 = pre-OpenGL, 2 = partial OpenGL, 3 = fuller OpenGL)oglStim.Type = 'oglStaticPrePostB';oglStim.Pars = pars;oglStim.FlagMinusOneToOne = true;oglStim.TextureParameters = setdiff((1:length(pars)),[6 7 10 11 16 17 20 21]);%% Define fields ori, globalAlpha, and positionoglStim.ori = [sinpars(:).orientation]'*ones(1,nframes);oglStim.globalAlpha = [sinpars(:).contrast]'*ones(1,nframes) /2;% notice division by two otherwise it does not work...oglStim.position = zeros(2,4);for igrat = 1:2    switch sinpars(igrat).shape        case 0            % it is an annulus            maxrad = max(1, sinpars(igrat).dimb/2);            nx = ceil(2*maxrad);            ny = ceil(2*maxrad);        case 1            % it is a rectangle            nx = max(1,sinpars(igrat).dima);            ny = max(1,sinpars(igrat).dimb);    end        % The position vector    x = round(sinpars(igrat).x + myscreen.Xmax/2 - nx/2);    y = round(sinpars(igrat).y + myscreen.Ymax/2 - ny/2);    oglStim.position(igrat,:) = [x y x+nx y+ny];endif flagNoTextures    returnend%% Define Frames and FrameSequence for each component gratingFrames          = cell(2,1);FrameSequence   = cell(2,1);for igrat = 1:2        % Spatial frequency in cycles/pixel    PixPerCycle = ltdeg2pix(1/sinpars(igrat).sfreq,myscreen);    sinpars(igrat).frequency = 1/PixPerCycle; % sf in cycles/pix        nx = diff(oglStim.position(igrat,[1 3]));    ny = diff(oglStim.position(igrat,[2 4]));        % Make a grid of x and y    [xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);        % Image of the spatial phase of the stimulus (in radians)    AngFreqs = -2*pi* sinpars(igrat).frequency * xx + sinpars(igrat).spatphase;        switch sinpars(igrat).shape        case 0            % an annulus            dd = sqrt(xx.^2+yy.^2);            WindowImage = double(dd >= sinpars(igrat).dima/2 & dd <= sinpars(igrat).dimb/2);        case 1            % a rectangle            WindowImage = double(ones(size(xx)));    end        % Make movies    fprintf(1,' Frames for grating %d...', igrat);    ContrastImage = sin( AngFreqs);    ContrastImage = sign(ContrastImage).*abs(ContrastImage);    if sinpars(igrat).sqwv        ContrastImage = (ContrastImage>eps)-(ContrastImage<-eps);    end    Frames{igrat}{1} =      ContrastImage  .* WindowImage;    Frames{igrat}{2} = 0 .* ContrastImage  .* WindowImage;        % the frame sequence    FrameSequence{igrat} = [2*ones(1,nframes_pre) ones(1,nframes_stim) 2*ones(1,nframes_post)];    end%% merge the stimuli% probably obsoleteoglStim.nperiods             = 1; % plobably important oglStim.srcRect = cell(2*nframes,1);% is this unused? what is it???% should be {240x1 cell}, and each of them should be {[],[]}% for iframe = 1:(2*nframes% 	oglStim.srcRect{iframe} = {[] []};% endoglStim.frames   = {[Frames{1}(:); Frames{2}(:) ]};% probably obsoleteoglStim.luts     =  { repmat([128 255 0 1:253]',1,3) repmat([128 255 0 1:253]',1,3) }';% importantoglStim.sequence.frames = [ FrameSequence{1}; (FrameSequence{2}+ length(Frames{1}) ) ];oglStim.sequence.frames = oglStim.sequence.frames(:);% probably obsoleteoglStim.sequence.luts   = [ ones(1,nframes)  ; ones(1,nframes) + 1 ];oglStim.sequence.luts   = oglStim.sequence.luts  (:);% probably importantoglStim.positionIndex = repmat([1; 2], nframes, 1);fprintf(1,'\n');return%% TO TEST IT:% [  durpre durstim durpost ...%    sf1 sph1 c1 ori1 dima1 dimb1 x1 y1 sqwv1 shape1...%    sf2 sph2 c2 ori2 dima2 dimb2 x2 y2 sqwv2 shape2]myscreen = ltScreenInitialize(2); %#ok<UNRCH>myscreen.Dist = 20;ltLoadCalibration(myscreen);% ltClearStimulus(Stim,'nowarnings');pars = [ 20 30 10 ...    10 180  50   0 100 300 -200 0 1 1 ...    20   0   0  90   0 300 -200 0 0 0 ];pars = [ 10 40 10 ...    10 0 50  90  100 300 0 0 0 0 ...    10 0 50   0   99 500 0 0 0 0 ];Stim = oglStimMake('oglStaticPrePostB',pars, myscreen);oglStimPlay(myscreen,Stim);newpars = [ 15 15 15 ...    10 0  0 25  45 100 300 200 0 0 ...    10 0 25  0  99 500   0   0 1 1 ];Stim = oglStimUpdateDisplayParameters(Stim,newpars,myscreen);oglStimPlay(myscreen,Stim);ltClearLoadedTextures;ltClearStimulus(Stim,'nowarnings');Screen('CloseAll');