function [Stim,noise] =  v2luts1grat1texn(pars,myscreen)% Stim =  v2luts1grat1tex(pars,myscreen)%% SEE CODE AT THE END OF THE FUNCTION TO TEST % ------ parse the pars (excuse the pun)SinPars = [];dur 	= pars(1)/10 ; %= dur; % Stim. durationctr.x	 			=  round(ltdeg2pix(pars (2)/10,myscreen)); % Centre x (deg*10).ctr.y				=  round(ltdeg2pix(pars( 3)/10,myscreen)); % Centre y (deg*10).SinPars.tFreq	 			= pars(4)/10 * 2; 	% 2x factor since presented every other framesSinPars.SpatialFrequency  	= pars(5)/100; 		SinPars.phase  				= pars(6)* (pi/180); 		SinPars.Contrast 	 		= pars(7)/100 * 2; % 2x factor since presented every other framesSinPars.Orientation 		= pars(8) * (pi/180); SinPars.innerRad			=  ceil(ltdeg2pix(pars( 9)/10,myscreen)/2); % inner diameter (deg*10).SinPars.outerRad			= floor(ltdeg2pix(pars(10)/10,myscreen)/2); % outer diameter (deg*10).SinPars.sqwv	= 0;	% 0=sine, 1=squareTexPars = [];TexPars.x = ctr.x;TexPars.y = ctr.y;TexPars.texelsize = ceil(ltdeg2pix(pars( 11)/10,myscreen)); % size of texture elements (deg*10)TexPars.nGrays = pars(12);TexPars.innerRad =  ceil(ltdeg2pix(pars(13)/10,myscreen)/2); % inner diameter (deg*10).TexPars.outerRad = floor(ltdeg2pix(pars(14)/10,myscreen)/2); % outer diameter (deg*10).TexPars.order = pars(15); % order of moment to vary (0,1,2,3,4,5)TexPars.moddepth = pars(16)/100; % modulation depth of deviations from uniform distr (0 to 100%).TexPars.statetex = pars(17); % seed of random sequence underlying texture generation%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if TexPars.outerRad == 0	Stim = cell(1,1);	nframes = round(myscreen.FrameRate * dur);	SinPars.tFreq = SinPars.tFreq /2;	SinPars.Contrast = SinPars.Contrast /2;else	Stim = cell(2,1);	nframes = round(myscreen.FrameRate * dur / 2);end%%%%%%%%%%%%%%% test gratingipatch = 1;Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars,myscreen,'reserve3');Stim{ipatch}= ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);[Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');Stim{ipatch}.luts = cell(nCluts,1); % allocationfor iClut = 1:nCluts	Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); endStim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initializationStim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation onlyfor iframe = 0:nframes - 1 % initialization	Stim{ipatch}.sequence.luts(iframe+1) = mod(iframe,nCluts) + 1;end%------- define position rectx1 = (round(myscreen.Xmax/2) - SinPars.outerRad);y1 = (round(myscreen.Ymax/2) - SinPars.outerRad);x2 = (round(myscreen.Xmax/2) + SinPars.outerRad);y2 = (round(myscreen.Ymax/2) + SinPars.outerRad);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim{ipatch}.nperiods = 1;%%%%%%%%%%%%%% mask texture if TexPars.outerRad==0; 	Stim = Stim{ipatch};	return;end;ipatch =2;[Stim{ipatch}.frames{1},noise] = makeTextureFrames(TexPars,nframes);Stim{ipatch}= ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);nreslutentries = 3;ilut = 1;Stim{ipatch}.luts{ilut} = zeros(256,3);Stim{ipatch}.luts{ilut}(1,1:3) = 128;Stim{ipatch}.luts{ilut}(2,1:3) = 255;Stim{ipatch}.luts{ilut}(3,1:3) = 0;Stim{ipatch}.luts{ilut}(4:256,1:3) = repmat(round([0:256/(256-nreslutentries):255])',1,3);% % generate unique frames sequence% % number of unique frames: nframes / TexPars.refreshrate % uframes 	= ... % for allocation and initialization%     mod(floor(rand(1,ceil(nframes/TexPars.refreshrate))*ntexframes),ntexframes)+1;% % % upsample frame sequence according to refresh rate% so = size(uframes);% sn = so*TexPars.refreshrate;% sc = so./sn + eps;% actual scaling between images, eps is needed% frames =  uframes(floor(sc(1)/2:sc(1):end)+1);% % % discard additional frames% Stim{ipatch}.sequence.frames = frames(1:nframes);Stim{ipatch}.sequence.frames = 1:nframes; % for allocation and initializationnCluts = length(Stim{ipatch}.luts);Stim{ipatch}.sequence.luts 		= mod([0:nframes-1],nCluts) +1;%------- define position rect[nx,ny]=size(Stim{2}.frames{1}{1});x1 = (round(myscreen.Xmax/2) - nx/2);y1 = (round(myscreen.Ymax/2) - nx/2);x2 = (round(myscreen.Xmax/2) + nx/2);y2 = (round(myscreen.Ymax/2) + nx/2);	Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);% The number of times you want to see the movie		Stim{ipatch}.nperiods = 1;returnfunction [frames,noise] = makeTextureFrames(TexPars,nframes)rescf= makeBasisFunctions(TexPars.nGrays);rand('state',TexPars.statetex);for iframe = 1:nframes	magnitude=TexPars.moddepth;		% pdf is sum uniform distribution with a basis function	% f(x) = P{X==x}	density = rescf(:,1) + magnitude*rescf(:,TexPars.order+1);        ntexels = ceil(TexPars.outerRad * 2 / TexPars.texelsize);    % [0,delta,1]    noise{iframe} = (randpdf(density,ntexels,ntexels)-1)/(TexPars.nGrays-1);        lowerbound = 3;upperbound = 255;    intensities = round(noise{iframe}*(upperbound-lowerbound))+lowerbound;	% upsample to obtain image with desired texel size.	so = size(intensities);	sn = so*TexPars.texelsize;	sc = so./sn + eps;% actual scaling between images, eps is needed	tempframe =  intensities(floor(sc(1)/2:sc(1):end)+1,floor(sc(2)/2:sc(2):end)+1,:);	% circular window. image size always even because specified by radius.	xx = round([0:sn(1)-1]-sn(1)/2);	[XX,YY]=meshgrid(xx,xx);	if any(size(XX)~=size(tempframe));		disp('texture array size does not match that of aperture');	end    	sel = find(XX.^2+YY.^2>TexPars.outerRad.^2 | XX.^2+YY.^2<TexPars.innerRad.^2);	tempframe(sel)=0; % background is gray    frames{iframe} = uint8(tempframe);endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function out = randpdf(frequencies,m,n);% out = randpdf(frequencies,m,n);% frequencies is the discrete pdf. must sum to one.if round(sum(frequencies)*1e4)/1e4 ~=1     error('frequencies must sum to one');endncategories = length(frequencies);pmax = max(frequencies); ratios = inf*ones(size(frequencies));sel = find(frequencies);ratios(sel) = pmax./frequencies(sel);numbers = [];ndraws = 1024;while length(numbers)<m*n	urand = ceil(rand(1,ndraws)*ncategories);	test = ratios(urand).*rand(1,ndraws)';	samples = find(test<1);	numbers = [numbers urand(samples)];end% fprintf(1,'Generated %i numbers. Output: %i.\n ',length(numbers),(m*n));out = reshape(numbers(1:m*n),m,n);return;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function rescf= makeBasisFunctions(ngrays)% rescf= make_orthogonal_basis_functions(ngrays)nbasisfunctions =5;% make nonorthogonal basisv = [0:ngrays-1]';f = [];for i = 1 : nbasisfunctions;    f(1:ngrays,i)=v.^(i-1);end% orthogonalizeorthf = gram_schmidt(f);% normalized each basis function to 1;ulevel = 1/ngrays;for i =1:nbasisfunctions    mlevel(i) = max(abs(orthf(:,i)));    rescf(:,i) = orthf(:,i)/abs(mlevel(i))*ulevel;endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function Qhat = gram_schmidt(a);%   gram_schmidt   -  script implementing the step-by-step%               Gram-Schmidt algorithm.%%[ rowsA, colsA ] = size(a) ;%Qhat = a(:,1)/norm(a(:,1)); %for j = 2:colsA  Qhat(:,j) = a(:,j) - Qhat*(Qhat'*a(:,j)) ;  Qhat(:,j) = Qhat(:,j)/norm( Qhat(:,j) );endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:SCREEN('CloseAll');iscreen = 0;myscreen = ltScreenInitialize(iscreen);		myscreen.Dist = 57;% pars:= [ dur x y tf1 sf1 ph1	c1 ori1 idiam1 odiam1  tex ngrays idiam2 odiam2 order depth seed]pars =   [ 20  0 0 20   10 0    0   0    0      40     4   12      30     100   3     100   99]Stim = v2luts1grat1texn(pars,myscreen);vsPlayStimulus(myscreen,Stim);SCREEN('CloseAll');temp = double(cell2mat(Stim{2}.frames{1}));hist(temp(find(temp>2)),100)