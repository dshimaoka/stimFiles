function [oglStim, NoisePars] = oglRandpos_sparse_alpha(pars,myscreen,~)% [oglStim] =  oglRandpos_sparse_alpha(pars,myscreen);% [oglStim, NoisePars] = oglRandpos_sparse_alpha(pars,myscreen); outputs random%           stimulus parameters. useful for functions that want to get the random%           stimulus sequences.%% Parameters are :% [dur c barwdth baseori nori nphase seed nfr bprob acfactor aprobfactor apos]%% oglStim = oglRandpos_sparse_alpha(pars,myscreen,~) is because a vs subfunction% (oglStimUpdateParameters) works by calling the function that generates% stimuli with a flag about if it needs to make new textures or not. this% part is avoided here because much of this function needs to run before% the positions are known anyway. might not be totally optimal but it works% 2010-06 ND created based on oglRandpos.m with some help from oglTwoGratings.m% 2010-07 ND added NoisePars output - useful for analysis routines.% 2010-10 ND fixed contrast problem by having global alpha control contrast% ------ parse the parametersp.dur 		  = pars(1)/10; % duration (converted from sec*10)p.c			  = pars(2)/100; % contrast (converted from %)p.barwdth     = ceil(ltdeg2pix(pars(3)/10,myscreen)); % width of bar (converted from deg*10 to pixels).p.overlap     = pars(4)./100; % overlap of stimuli (converted from %)p.baseori     = pars(5); % base orientation in degreesp.seed		  = pars(6); % the seed of random number generatorp.nfr		  = pars(7); % the number of interpolated framesp.bprob_orig  = pars(8)./100; %the probability of a blank screen (converted from %)p.ac          = pars(9)/100; % adapter contrast (converted from %)p.aprobfactor = pars(10)/100; % factor of adapter prob (converted from %)p.apos        = ceil(ltdeg2pix(pars(11)/10,myscreen)); % adapter position (converted from deg*10 to pixels)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fundamental fieldsoglStim = oglStimNew(); % preallocate so you have correct order of parametersoglStim.Generation = 3; % 3rd gen (1 = pre-OpenGL, 2 = partial OpenGL, 3 = fuller OpenGL)oglStim.Type = 'oglRandpos_sparse';oglStim.Pars = pars;oglStim.FlagMinusOneToOne = true;oglStim.TextureParameters = 1:length(pars);% The number of frames in the entire stimulusnframes = ceil(p.dur * myscreen.FrameRate);nstims = nframes/p.nfr;%%% Make a grid of x and ynx = p.barwdth; % width of the barp.barlgth = round(sqrt(myscreen.Ymax^2 + myscreen.Xmax^2)); % diagonal of screen (max length conceivable in pixels)ny = p.barlgth;[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);% home positions% center of screen. could be a parameter in future if want to limit portion% of screen on which you show stimuli so that you don't waste a lot of% stimuli. in that case would have to change the automatic calculation of% stimulus position and numberp.x = 0; p.y = 0; % in pixels% Compute the orientations of the stimulidori = 0;p.nori = 1;diffori = zeros(1,p.nori);diffori(1) = 0 + pi*(p.baseori)/180; % base orientation after converting to radiansfor iori = 2:p.nori	diffori(iori) = diffori(iori-1) + dori;enddiffori = mod(diffori,2*pi); % these are the orientations used, expressed as angles in radiansdifforideg = diffori * 180 / pi; % convert to deg% Compute the positions of the stimuli% first make it such that fills space for screenp.overlap = min(p.overlap,0.99); % limit overlap to 99%p.npos = ceil(myscreen.Xmax/p.barwdth);if p.npos < 2    p.npos = 1;    diffpos = 0;else    dpos = round((myscreen.Xmax-p.barwdth)./(p.npos-1));    diffpos = -dpos*(p.npos-1)/2:(p.barwdth+1):dpos*(p.npos-1)/2;end% now fill in positions more finely given requested degree of overlapdiffpos = diffpos(1):dpos*(1-p.overlap):diffpos(end);p.npos = length(diffpos);p.stimprob = 1/p.npos; % base probability of showing any particular stimulusfprintf(1,'Number of stimuli = %d each with probability %1.3f without considering blanks and adapters.\n',p.npos,p.stimprob);fprintf(1,'With this duration and frame interpolation you are going to show each stimulus %d times.\n',round(nstims/p.npos));% get the adapter position and contrastp.apos_ix_applied = find(hist(p.apos,diffpos));p.apos_applied = diffpos(p.apos_ix_applied); % in pixelsp.ac = min(p.ac,1); % max is full contrast%  the phases of the stimuli - just use 0 and pi for white and black stimulidiffph = [0 pi];p.nphase = size(diffph,2);% MAKE ALL THE FRAMESmymovie = cell(p.nphase,1);iframe = 0;% first make the stimuli frames at the desired stimulus contrastthisori = 0; % stimulus will be rotated during presentationthissf = 0;% thissf = 1./ltdeg2pix(1/p.sf,myscreen); % sf in cycles/pixfor iph = 1:p.nphase    iframe = iframe+1;    thisphase = diffph(iph);    % make the stimulus aperture    angfreq = -2*pi*thissf*( cos(thisori).*xx + sin(thisori).*yy );%     movieimage = p.c * cos(thisphase + angfreq);    movieimage = 1 * cos(thisphase + angfreq);    mymovie{iframe} = uint8(round(( movieimage + 1 )*126 + 2));    % and at this point movieimage goes bet 2 and 254    mymovie{iframe} = movieimage;    % and at this point movieimage goes bet -1 and 1end% need to decide if adapter is a blank or a stimulus and then what will be desired probabilityif p.ac == 0 % adapter is actually a blank    fprintf(1, 'Applying adapter probability factor to blank probability\n');    p.bprob = p.bprob_orig*p.aprobfactor;    p.aprob = 0; % so that you don't make extra textures that are meaninglesselse % adapter is part of the stimulus set    p.bprob = p.bprob_orig;    p.aprob = min(p.stimprob*p.aprobfactor,1); % max is everything set to adapterend% now make the blank if there is onenblnk = 0;if p.bprob > 0	nblnk = 1;    % make 1 frame for the blank stim    iframe = iframe+1;    movieimage = zeros(size(xx));    mymovie{iframe} = uint8(round((movieimage + 1)*126 + 2));    % and at this point movieimage contains gray (128)    mymovie{iframe} = movieimage;    % and at this point movieimage contains gray (0)end% now make the adapter stimulus if there is oneif p.aprob>0    % first make the movie frames - basically same as the stimulus frames    % but at a different contrast specified by p.ac and you make two, one    % that is at the increased luminance and one that is at a decreased    % luminance.     for iph = 1:p.nphase        iframe = iframe+1;        thisphase = diffph(iph);        % make the stimulus aperture        angfreq = -2*pi*thissf*( cos(thisori).*xx + sin(thisori).*yy );%         movieimage = p.ac * cos(thisphase + angfreq);        movieimage = 1 * cos(thisphase + angfreq);        mymovie{iframe} = uint8(round(( movieimage + 1 )*126 + 2));        % and at this point movieimage goes bet 2 and 254        mymovie{iframe} = movieimage;        % and at this point movieimage goes bet -1 and 1    end        % now figure out the probability with which we have to set frames to    % the adapter, incorporates the idea that the adapter will generally be    % one of the stimuli presented.         % because the adapter is forced to be one of the stimulus positions    padapt = p.stimprob;  % probability that the adaptor is shown by chance    if p.aprob < padapt        fprintf(1, 'Chucking out stimuli to under-represent a position\n');    elseif p.aprob == padapt        fprintf(1, 'Neither over-representing nor under-representing a position\n');        pa = 0;    else %         fprintf(1, 'Changing stimuli to over-represent a position\n');        pa = (p.aprob - padapt) / (1 - padapt);        % the idea is that p.aprob = pa + (1-pa)*padapt, where:        % p.aprob is the desired probability of the adapter        % padapt is the probability of the adapter within the stimulus sequence        % pa is the probability of explicitly setting a stimulus to the        % adapter in order to achieve the desired adapter probability. i.e.        % it is the incremental probability of the adapter from the        % stimulus probability.    endend% That's it for the framesoglStim.frames{1} = mymovie;% % MAKE ALL THE LUTSlinClut = [ [128 128 128]; [255 255 255]; [ 0 0 0]; round(linspace(0,255,253))'*[1 1 1] ];oglStim.luts{1} = linClut;oglStim.sequence.luts = ones(1,nframes);% The position of the stimulus% First: center the stim where the user wants itx1 = round(myscreen.Xmax/2) - round(p.barwdth/2);y1 = round(myscreen.Ymax/2) - round(p.barlgth/2);x2 = round(myscreen.Xmax/2) + round(p.barwdth/2);y2 = round(myscreen.Ymax/2) + round(p.barlgth/2);homePos = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);% Now: shift the stim relative to thatframePos = cell(p.nori,1);for iori = 1 : p.nori    framePos{iori} = zeros(p.npos,4);    for ipos = 1 : p.npos        shiftX = cos(diffori(iori)) * diffpos(ipos);        shiftY = sin(diffori(iori)) * diffpos(ipos);        framePos{iori}(ipos,:) = OffsetRect(homePos, shiftX, shiftY);    endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% not sure what to do if have more than one orientation. probably have to% have another set for that. but won't worry about that here.oglStim.position = framePos{1};% oglStim.offset = [p.x p.y];%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DEFINE THE RANDOM SEQUENCE OF THE FRAMES% Set the seed, and select the Matlab 4 rand num generatorrand('seed',p.seed);nstimPerPhase = p.nori*p.npos;nsettoBlanks = round(p.bprob*nstimPerPhase/(1-p.bprob));ntotalStims = p.nphase*(nstimPerPhase+nsettoBlanks);% The sequence of frames (position and spatial phase)frameseq = zeros(1, nframes);% adjust which frames are set to the blankstimseq = ceil(rand(1,nframes)*ntotalStims); % number of frames temporaryframeseq(stimseq > ntotalStims-p.nphase*nsettoBlanks) = p.nphase+nblnk; % blank frames% select which stimulus phase for non-blank stimulifor iphase = 1 : p.nphase    frameseq(stimseq > (iphase-1)*nstimPerPhase & stimseq <= iphase*nstimPerPhase) = iphase;end% now this messes up if the p.bprob > 1 - then the computations are not% right. but in that case, the entire frameseq should be set to be blank% framesif p.bprob >= 1    frameseq(:) = p.nphase+nblnk; % blank framesend% The sequence of orientations and positionsrand('seed',p.seed+10);oriIndex = ceil(rand(1,nframes)*p.nori);rand('seed',p.seed+20);posIndex = ceil(rand(1,nframes)*p.npos);% adjust which frames are set to the adapterrand('seed',p.seed+30);posIndex_adapted = posIndex;frameseq_adapted = frameseq;if p.ac ~= 0 % only do this if have adapters of non-zero contrast    if p.aprobfactor >= 1 % need to over-represent a position        setFramestoAdapter = (rand(1,nframes)<=pa);        posIndex_adapted(setFramestoAdapter) = p.apos_ix_applied;            else % need to under-represent a position        aixframes = find(posIndex==p.apos_ix_applied);        setAFramestoOther = rand(1,length(aixframes))>p.aprobfactor;        rand('seed',p.seed+40);        long_random_string = ceil(p.npos*rand(1,3*nframes));long_random_string(long_random_string==p.apos_ix_applied)=[];        posIndex_adapted(aixframes(setAFramestoOther)) = long_random_string(1:sum(setAFramestoOther));    end    % now get all stimuli at adapting position and set to be the adapting frame    % so that all stimuli at adapting position are at adapting contrast    new_frame_ixs = p.nphase+nblnk+(1:p.nphase);    AFrames = (posIndex_adapted==p.apos_ix_applied) & (frameseq~=p.nphase+1);    frameseq_adapted(AFrames) = new_frame_ixs(1) -1 + ceil((new_frame_ixs(end)-new_frame_ixs(1)+1)*rand(1,sum(AFrames)));end% oglStim.globalAlpha = ones(1,nframes);globalAlpha = p.c*ones(1,nframes);% now pick out the adapted frames and change those to the adapted contrastif exist('AFrames','var'), globalAlpha(AFrames) = p.ac; end% Interpolate these frames frameindex = floor(1:1/p.nfr:nframes);oglStim.sequence.frames = frameseq_adapted(frameindex(1:nframes));oglStim.ori = difforideg(oriIndex(frameindex(1:nframes)));oglStim.positionIndex = posIndex_adapted(:,frameindex(1:nframes));oglStim.globalAlpha = globalAlpha(1,frameindex(1:nframes)) / 2; % notice division by 2% for iframe = 1 : length(oglStim.ori)%     oglStim.position(iframe,:) = framePos{oriIndex(frameindex(iframe))}(posIndex(frameindex(iframe)),:);% end% oglStim.offset = [p.x p.y];% The number of times you want to see the movie		oglStim.nperiods = 1;oglStim.srcRect = cell(1,nframes);%% Noise Parameters --> gets the random stimulus sequencesdiffpos_deg = ltpix2deg(oglStim.position(:,1)+unique(diff(diffpos)) - (myscreen.Xmax/2),myscreen)';NoisePars.sequence.positions = oglStim.positionIndex;NoisePars.sequence.frames = oglStim.sequence.frames;NoisePars.possible.positions = oglStim.position;NoisePars.possible.frames = unique(frameseq_adapted);% compute the parameters of each unique stimulusiImage = 0; % unique combination of ori, pos, phaseiMovieFrame = 0; % unique frames computedfor iph = 1:p.nphase    iMovieFrame = iMovieFrame + 1;    for ipos = 1:p.npos        for iori = 1:p.nori            iImage = iImage+1;            NoisePars.ori(  iImage) = diffori(iori)/pi*180;            NoisePars.pos(  iImage) = diffpos_deg(ipos); % pos in deg            NoisePars.phase(iImage) = diffph(iph)/pi*180;            NoisePars.c(    iImage) = p.c;            NoisePars.sf(   iImage) = 0;            % images with different ori and pos share the same MovieFrame            NoisePars.iMovieFrame( iImage ) = iMovieFrame;        end    endendif p.bprob > 0    iMovieFrame = iMovieFrame + 1; % one MovieFrame for the blank stimulus    % the blank frame    for ibl = 1        iImage = iImage+1;        NoisePars.ori(iImage) = NaN;        NoisePars.pos(iImage) = NaN;        NoisePars.phase(iImage) = NaN;        NoisePars.c(iImage) = 0;        NoisePars.sf(iImage) = NaN;        NoisePars.iMovieFrame( iImage ) = iMovieFrame;    endendif p.aprob > 0    for iph = 1:p.nphase        iMovieFrame = iMovieFrame + 1;        for ipos = 1:p.npos            for iori = 1:p.nori                iImage = iImage+1;                NoisePars.ori(  iImage) = diffori(iori)/pi*180;                NoisePars.pos(  iImage) = diffpos_deg(ipos); % SF in cpd                NoisePars.phase(iImage) = diffph(iph)/pi*180;                NoisePars.c(    iImage) = p.ac;                NoisePars.sf(   iImage) = 0;                % images with different ori and pos share the same MovieFrame                NoisePars.iMovieFrame( iImage ) = iMovieFrame;            end        end    endend% build the virtual sequenceNoisePars.VirtualSequence=NaN(1,nframes);if p.bprob>0    NoisePars.VirtualSequence(NoisePars.sequence.frames==3) = find(NoisePars.iMovieFrame==3);endfor iframe = 1:nframes    tempix = find( NoisePars.sequence.frames(iframe) == NoisePars.iMovieFrame & ...        diffpos_deg(NoisePars.sequence.positions(iframe)) == NoisePars.pos );    if ~isempty(tempix)        NoisePars.VirtualSequence(iframe) = tempix;    endendreturn%% Code to test the function in StimBoxwhichScreen = 2;myscreen = ltScreenInitialize(whichScreen);myscreen.Dist = 28;ltLoadCalibration(myscreen);% myscreen = ScreenLogLoad('F100617',1,2,'stim');myscreen = ScreenLogLoad('M100722',1,11,'stim');%%% The parametersdur 		= 100; % sec*10c			= 10; % contrast in %barwdth		= 50; % bar widthoverlap     = 10; % amount of overlap of stimuli in percentbaseori     = 0; %starting orientation in sequenceseed		= 1; % the seed of random number generatornfr			= 10; % the number of interpolated framesbprob       = 20; % percent chance that the stimulus is blankac          = 10; % contrast of adapter in %aprobfactor = 100; % factor probability of adapter in % (100 means no change)apos        = 0; % position of adapting position i n deg*10pars_sparse = [dur c barwdth overlap baseori seed nfr bprob ac aprobfactor apos];Stim_sparse = oglStimMake('oglRandpos_sparse',pars_sparse, myscreen);%%oglStimPlay(myscreen,Stim_sparse);%%ltClearStimulus(Stim_sparse,'nowarnings');Screen('CloseAll');