function Stim =  v2lut2gratdel(pars,myscreen)% Stim =  v2lut2gratdel(pars,myscreen)%% code for v2lut2gratdel.x%% Just like vis2luts2grat but can do initial delay%% Parameters are % [ dur ...%	tf1 sf1 ph1 c1 ori1 x1 y1 idiam1 odiam1 flicker1%	tf2 sf2 ph2 c2 ori2 x2 y2 idiam2 odiam2 flicker2 %   delay ]%% SEE CODE AT THE END OF THE FUNCTION TO TEST % pars = [ 20    40 10 0 50 90 0 0 0 40 0    30 10 0 50 45 20 -20 20 60 1 10 ]dur 	= pars(1)/10 /2; %= dur; % Stim. durationSinPars = [];SinPars(1).tFreq	 			= pars(2)/10 * 2; 	SinPars(1).SpatialFrequency  	= pars(3)/100; 		SinPars(1).phase  				= pars(4)* (pi/180); 		SinPars(1).Contrast 	 		= pars(5)/100 * 2; SinPars(1).Orientation 			= pars(6) * (pi/180); ctr(1).x	 			=  round(ltdeg2pix(pars (7)/10,myscreen)); % Centre x (deg/10).ctr(1).y				=  round(ltdeg2pix(pars( 8)/10,myscreen)); % Centre y (deg/10).SinPars(1).innerRad			=  ceil(ltdeg2pix(pars( 9)/10,myscreen)/2); % inner diameter (deg/10).SinPars(1).outerRad			= floor(ltdeg2pix(pars(10)/10,myscreen)/2); % outer diameter (deg/10).SinPars(1).sqwv	= 0;	% 0=sine, 1=squareSinPars(1).direction = (pars(11)==0);SinPars(2).tFreq	 			= pars(12)/10 * 2; 	SinPars(2).SpatialFrequency  	= pars(13)/100; 		SinPars(2).phase  				= pars(14)* (pi/180); 		SinPars(2).Contrast 	 		= pars(15)/100 * 2; SinPars(2).Orientation 			= pars(16) * (pi/180); ctr(2).x	 			=  round(ltdeg2pix(pars(17)/10,myscreen)); % Centre x (deg/10).ctr(2).y				=  round(ltdeg2pix(pars(18)/10,myscreen)); % Centre y (deg/10).SinPars(2).innerRad			=  ceil(ltdeg2pix(pars(19)/10,myscreen)/2); % inner diameter (deg/10).SinPars(2).outerRad			= floor(ltdeg2pix(pars(20)/10,myscreen)/2); % outer diameter (deg/10).SinPars(2).sqwv	= 0;	% 0=sine, 1=squareSinPars(2).direction = (pars(21)==0);delay 	= pars(22)/10 /2; %= dur; % initial delaynframes = round(myscreen.FrameRate * dur);ndelayframes = round(myscreen.FrameRate * delay); % these should be blanknstimframes  = nframes - ndelayframes;if nstimframes < 0	warning('-----> Delay is longer than stimulus!!!');	nstimframes = 0;	ndelayframes = nframes;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim = cell(2,1);% Define blanklut..blanklut=127*ones(256,3);blanklut(1,:) = 128;blanklut(2,:) = 255;blanklut(3,:) = 1;for ipatch = 1:2		Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);		[Cluts, nCluts] = ltMakeGratingCluts(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch}.luts = cell(nCluts+1,1); % allocation	for iClut = 1:nCluts		Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); 	end	Stim{ipatch}.luts{iClut+1} = blanklut;	Stim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initialization	Stim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation only	for iframe = 1:ndelayframes		Stim{ipatch}.sequence.luts(iframe) = iClut+1; % this one is the blank	end		for istimframe = 1:nstimframes		Stim{ipatch}.sequence.luts(istimframe+ndelayframes) = mod(istimframe-1,nCluts) + 1;	end		%------- define position rect	x1 = (round(myscreen.Xmax/2) - SinPars(ipatch).outerRad);	y1 = (round(myscreen.Ymax/2) - SinPars(ipatch).outerRad);	x2 = (round(myscreen.Xmax/2) + SinPars(ipatch).outerRad);	y2 = (round(myscreen.Ymax/2) + SinPars(ipatch).outerRad);		Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr(ipatch).x,ctr(ipatch).y);		Stim{ipatch}.nperiods = 1;	endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 65;ltLoadCalibration(myscreen,3);pars = [ 43    10 10 0 50 90 0 0 0 40 0    5 10 0 50 45 20 -20 20 60 1    3 ];Stim = v2lut2gratdel(pars,myscreen);vsPlayStimulus(myscreen,Stim{1},'norush');	vsPlayStimulus(myscreen,Stim{2});	vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');