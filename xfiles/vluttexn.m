function [Stim,noise] =  vluttexn(pars,myscreen)% [Stim,noise] =  vluttexn(pars,myscreen)% % 9/1/04 vb created% 9/20/04 vb optimized (randpdf2)% 10/7/04 vb now returns noise arrayTexPars = [];dur 	= pars(1)/10 ; %= dur; % Stim. durationTexPars.x	=  round(ltdeg2pix(pars (2)/10,myscreen)); % Centre x (deg*10).TexPars.y	=  round(ltdeg2pix(pars( 3)/10,myscreen)); % Centre y (deg*10).TexPars.nfr = pars(4); % repaint every nfr frameTexPars.ufr = pars(5); % not used (was used in vtexn)TexPars.ntex = pars(6); % number of tex elementsTexPars.nGrays = pars(7); % number of gray levelsTexPars.innerRad =  ceil(ltdeg2pix(pars(8)/10,myscreen)/2); % inner diameter (deg*10).TexPars.outerRad = floor(ltdeg2pix(pars(9)/10,myscreen)/2); % outer diameter (deg*10).TexPars.order = pars(10); % order of moment to vary (0,1,2,3,4,5)TexPars.moddepth = pars(11)/100; % modulation depth of deviations from uniform distr (0 to 100%).TexPars.statetex = pars(12); % seed of random sequence underlying texture generationdurframes = round(myscreen.FrameRate * dur); % stim duration in framesnrepaints = ceil(durframes / TexPars.nfr); % number of stim repaintsntexluts = nrepaints;ntexelements = TexPars.ntex^2;%%%%%%%%%%%%%%% make texturesrescf= makeBasisFunctions(TexPars.nGrays);rand('state',TexPars.statetex);    magnitude=TexPars.moddepth;	lowerbound = 3;upperbound = 255;% ntexels = ceil(TexPars.outerRad * 2 / TexPars.texelsize);TexPars.texelsize = ceil(TexPars.outerRad * 2 / TexPars.ntex);so = [TexPars.ntex,TexPars.ntex];sn = so*TexPars.texelsize;sc = so./sn + eps; % actual scaling between images, eps is needed% circular window. image size always even because specified by radius.xx = round([0:sn(1)-1]-sn(1)/2);[XX,YY]=meshgrid(xx,xx);ZZ2 = XX.^2+YY.^2;sel= find( ZZ2 > TexPars.outerRad.^2 | ZZ2 < TexPars.innerRad.^2);if ntexelements>upperbound-lowerbound    warning('ceiled ntex which cannot be bigger than 15');	TexPars.ntex=15;endlutentries = reshape(lowerbound:lowerbound+ntexelements-1,TexPars.ntex,TexPars.ntex);tempframe =  lutentries(floor(sc(1)/2:sc(1):end)+1,floor(sc(2)/2:sc(2):end)+1,:);if ~all(size(tempframe)==size(XX))    warning('Frame and mask mismatch!');    return;endtempframe(sel) = 0; % background is gray% imagesc(tempframe);colormap gray;axis square;Stim.frames{1}{1} = tempframe;Stim= ltMakeOffScreenWindows(myscreen,Stim,1);%%%%%%%%%%%%%%% make luts% make pdfdensity = rescf(:,1) + magnitude*rescf(:,TexPars.order+1);noiseflag =false;if nargout>1    noise = {}; % return arg for analysis, not stimulation    noiseflag = true;end% generate random numbers for all luts [0,1]temp = (randpdf2(density,ntexelements*ntexluts,1)-1)/(TexPars.nGrays-1);% rescale [0,255]intensities = round(temp*255);defaultlut = zeros(256,3);defaultlut(1,1:3) = 128;defaultlut(2,1:3) = 255;defaultlut(3,1:3) = 0;lutrows = lowerbound+1:lowerbound+ntexelements;lutcols = 1:3;for ilut = 1:ntexluts    Stim.luts{ilut} = defaultlut;	    sel = (ilut-1)*ntexelements+1:ilut*ntexelements;	Stim.luts{ilut}(lutrows,lutcols) = intensities(sel)*[1 1 1];        if noiseflag; noise{ilut}= reshape(temp(sel),TexPars.ntex,TexPars.ntex);end;endStim.sequence.frames = ones(1,durframes);ulutseq  =  1:ntexluts;so = size(ulutseq);sn = so*TexPars.nfr;sc = so./sn + eps;% actual scaling between images, eps is needed% upsample frame sequence according to refresh rateStim.sequence.luts =  ulutseq(floor(sc(1)/2:sc(1):end)+1);%------- define position rect[nx,ny]=size(Stim.frames{1}{1});x1 = (round(myscreen.Xmax/2) - nx/2);y1 = (round(myscreen.Ymax/2) - nx/2);x2 = (round(myscreen.Xmax/2) + nx/2);y2 = (round(myscreen.Ymax/2) + nx/2);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],TexPars.x,TexPars.y);% The number of times you want to see the movie		Stim.nperiods = 1;return%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function out = randpdf(frequencies,m,n);% out = randpdf(frequencies,m,n);% frequencies is the discrete pdf. must sum to one.if round(sum(frequencies)*1e4)/1e4 ~=1 	str = sprintf('frequencies sum to %2.3f',sum(frequencies));    error(str);endncategories = length(frequencies);pmax = max(frequencies); ratios = inf*ones(size(frequencies));sel = find(frequencies);ratios(sel) = pmax./frequencies(sel);numbers = [];volleysiz = 1024;while length(numbers)<m*n	urand = ceil(rand(1,volleysiz)*ncategories);	test = ratios(urand).*rand(1,volleysiz)';	samples = find(test<1);	numbers = [numbers urand(samples)];end% fprintf(1,'Generated %i numbers. Output: %i.\n ',length(numbers),(m*n));out = reshape(numbers(1:m*n),m,n);return;% % test randpdf functions% ncat = 24;% noise1=randpdf(ones(ncat,1)/ncat,TexPars.ntex^2*1e3,1);% noise2=randpdf2(ones(ncat,1)/ncat,TexPars.ntex^2*1e3,1);% subplot(2,1,1);% [n1] = hist(noise1,ncat);% subplot(2,1,2)% [n2] = hist(noise2,ncat);% [ ones(ncat,1)/ncat n1'/sum(n1) n2'/sum(n2)]%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function out = randpdf2(pdf,m,n);nx = length(pdf);cdf = cumsum(pdf);nlut = 1e3;yy = linspace(0,1,nlut);lut = zeros(nlut,1);lut ( find ( yy <= cdf(1) ) ) = 1;for ix = 2:nx	lut ( find ( yy > cdf(ix-1) & yy <= cdf(ix) ) ) = ix;endunifrands = ceil(rand(1,m*n)*nlut);unifrands(find(unifrands==0))=1;pdfrands = lut(unifrands);out = reshape(pdfrands,m,n);return;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function rescf= makeBasisFunctions(ngrays)% rescf= make_orthogonal_basis_functions(ngrays)nbasisfunctions =7;% make nonorthogonal basisv = [0:ngrays-1]';f = [];for i = 1 : nbasisfunctions;    f(1:ngrays,i)=v.^(i-1);end% orthogonalizeorthf = gram_schmidt(f);% normalized each basis function to 1;ulevel = 1/ngrays;for i =1:nbasisfunctions    mlevel(i) = max(abs(orthf(:,i)));    rescf(:,i) = orthf(:,i)/abs(mlevel(i))*ulevel;endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function Qhat = gram_schmidt(a);%   gram_schmidt   -  script implementing the step-by-step%               Gram-Schmidt algorithm.%%[ rowsA, colsA ] = size(a) ;%Qhat = a(:,1)/norm(a(:,1)); %for j = 2:colsA  Qhat(:,j) = a(:,j) - Qhat*(Qhat'*a(:,j)) ;  Qhat(:,j) = Qhat(:,j)/norm( Qhat(:,j) );endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:SCREEN('CloseAll');myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;% pars:= [ dur x y nfr ufr ntex ngrays idiam2 odiam2 order moddepth seed]pars =   [200  0 0  1   1  1     5     0      100    2    100   99];tic;[Stim,noise] = vluttexn(pars,myscreen);toc;vsPlayStimulus(myscreen,Stim);