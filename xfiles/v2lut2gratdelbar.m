function Stim =  v2lut2gratdel(pars,myscreen)% Stim =  v2lut2gratdel(pars,myscreen)%% code for v2lut2gratdel.x%% Just like vis2luts2grat but can do initial delay%% Parameters are % [ dur ...%	tf1 sf1 ph1 c1 ori1 x1 y1 sizex1 sizey1 flicker1%	tf2 sf2 ph2 c2 ori2 x2 y2 sizex2 sizey2 flicker2 %   delay ]%% SEE CODE AT THE END OF THE FUNCTION TO TEST % pars = [ 20    40 10 0 50 90 0 0 10 80 0    30 10 0 50 45 20 -20 80 20 1   10 ]dur 	= pars(1)/10 /2; %= dur; % Stim. durationSinPars = [];ipar = 0;for igrat = 1:2	SinPars(igrat).tFreq	 			= pars(ipar+2)/10 * 2; 		SinPars(igrat).SpatialFrequency  	= pars(ipar+3)/100; 			SinPars(igrat).phase  				= pars(ipar+4)* (pi/180); 			SinPars(igrat).Contrast 	 		= pars(ipar+5)/100 * 2; 	SinPars(igrat).Orientation 			= pars(ipar+6) * (pi/180); 	ctr(igrat).x	 					=  round(ltdeg2pix(pars (ipar+7)/10,myscreen)); % Centre x (deg/10).	ctr(igrat).y						=  round(ltdeg2pix(pars( ipar+8)/10,myscreen)); % Centre y (deg/10).	SinPars(igrat).sizeX				=  ceil(ltdeg2pix(pars( ipar+9)/10,myscreen)); % size x (deg/10).	SinPars(igrat).sizeY				=  ceil(ltdeg2pix(pars(ipar+10)/10,myscreen)); % size y (deg/10).	SinPars(igrat).sqwv					= 0;	% 0=sine, 1=square	SinPars(igrat).direction 			= (pars(ipar+11)==0);	ipar = 10;enddelay 	= pars(22)/10 /2; %= dur; % initial delaynframes = round(myscreen.FrameRate * dur);ndelayframes = round(myscreen.FrameRate * delay); % these should be blanknstimframes  = nframes - ndelayframes;if nstimframes < 0	warning('-----> Delay is longer than stimulus!!!');	nstimframes = 0;	ndelayframes = nframes;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim = cell(2,1);% Define blanklut..blanklut=127*ones(256,3);blanklut(1,:) = 128;blanklut(2,:) = 255;blanklut(3,:) = 1;for ipatch = 1:2		Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);		[Cluts, nCluts] = ltMakeGratingCluts(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch}.luts = cell(nCluts+1,1); % allocation	for iClut = 1:nCluts		Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); 	end	Stim{ipatch}.luts{iClut+1} = blanklut;	Stim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initialization	Stim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation only	for iframe = 1:ndelayframes		Stim{ipatch}.sequence.luts(iframe) = iClut+1; % this one is the blank	end		for istimframe = 1:nstimframes		Stim{ipatch}.sequence.luts(istimframe+ndelayframes) = mod(istimframe-1,nCluts) + 1;	end		%------- define position rect	x1 = round(myscreen.Xmax/2 - SinPars(ipatch).sizeX/2);	y1 = round(myscreen.Ymax/2 - SinPars(ipatch).sizeY/2);	x2 = x1 + SinPars(ipatch).sizeX;	y2 = y1 + SinPars(ipatch).sizeY;	x2 = max(x2,x1+1); % must be at least one pixel...	y2 = max(y2,y1+1);		% Buggy code (used up to Catz048, fixed by MC on 27-09-2004)	% 	x1 = (round(myscreen.Xmax/2) - SinPars(ipatch).sizeX/2);% 	y1 = (round(myscreen.Ymax/2) - SinPars(ipatch).sizeY/2);% 	x2 = (round(myscreen.Xmax/2) + SinPars(ipatch).sizeX/2);% 	y2 = (round(myscreen.Ymax/2) + SinPars(ipatch).sizeY/2);% 	x2 = max(x2,x1+1); % must be at least one pixel...% 	y2 = max(y2,y1+1);		SinPars(igrat).sizeY		Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr(ipatch).x,ctr(ipatch).y);		Stim{ipatch}.nperiods = 1;	endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 65;ltLoadCalibration(myscreen,3);dur  = 43;tf1	 = 10;sf1  = 10;ph1  = 0;c1   = 50;ori1 = 0;xc1  = 0;yc1  = 0;xs1	 = 10;ys1  = 40;dr1  = 0;	% whether it should drift or nottf2	 = 10;sf2  = 5;ph2  = 0;c2   = 0;ori2 = 0;xc2  = 0;yc2  = -100;xs2	 = 10;ys2  = 40;dr2  = 0;	% whether it should drift or notdelay = 10;pars = [ dur...	tf1 sf1 ph1 c1 ori1 xc1 yc1 xs1 ys1 dr1...	tf2 sf2 ph2 c2 ori2 xc2 yc2 xs2 ys2 dr2    delay ];Stim = v2lut2gratdelbar(pars,myscreen);vsPlayStimulus(myscreen,Stim{1});	%,'norush'vsPlayStimulus(myscreen,Stim{2});	vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');