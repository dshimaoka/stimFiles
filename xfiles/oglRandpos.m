function [Stim, NoisePars] = oglRandpos(pars,myscreen)% "smarter" randpos stimulus based on the original version by RF%%% [Stim, NoisePars] =  vrandpos(pars,myscreen);%% Parameters are :% [dur c barlgth barwdth sf nori npos nphase seed nfr blankProb]%% 2008-01 LB% 2008-01 MC added bit at the end with VirtualSequence% 2008-03 LB made the NoisePars structure identical to that used by oglRingach% 2008-03 LB added the computation of NoisePars.screen (for StimFrames)% ------ parse the parametersp.dur 		= pars(1)/10; % duration.p.c			= pars(2)/100; % contrastp.x			= 0; p.y			= 0; p.posDiam   = ceil(ltdeg2pix(pars(3)/10,myscreen));p.barlgth   = p.posDiam;p.barwdth   = ceil(ltdeg2pix(pars(4)/10,myscreen)); % width of bar (deg/10).p.sf        = pars(5)/100; %spatial frequency (sf/100);p.nori		= pars(6); % number of orientationsp.npos      = pars(7); %number of stimulus positions (per orientation)p.nphase	= pars(8); % the number of spatial phasesp.seed		= pars(9); % the seed of random number generatorp.nfr		= pars(10); % the number of interpolated framesp.bprob		= pars(11)./100; %the probability of a blank screen (in %)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The radius of the stimuli% p.outerRad = round(p.diam/2);% Make a grid of x and ynx = p.barwdth; % width of the barny = p.barlgth; % diagonal (max length conceivable)[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);% window = ( xx.^2+yy.^2 < p.diam^2/4 ); % circular window% Compute the orientations of the stimuliif p.nori < 2	dori = 0;	p.nori = 1;else	oridist = angle(exp(i*pi));	% There is no motion, oris is between 0 and pi	if oridist < 0;		dori = pi/p.nori;	else		% This makes sure that the first and last oris are not too similar		dori = oridist/(p.nori-1);		if pi-(p.nori-1)*dori < dori			dori = pi/p.nori;		end	endenddiffori = zeros(1,p.nori);diffori(1) = 0;for iori = 2:p.nori	diffori(iori) = diffori(iori-1) + dori;enddiffori = mod(diffori,2*pi); % these are the orientations used, expressed as anglesdifforideg = diffori * 180 / pi; % convert to deg% Compute the positions of the stimuliif p.npos < 2    %dpos = 0;    p.npos = 1;    diffpos = 0;else    dpos = round((p.posDiam-p.barwdth)./(p.npos-1));    diffpos = dpos.*linspace(-(p.npos-1)./2, (p.npos-1)./2,p.npos);end% Compute the phases of the stimuliif p.nphase > 1	diffph = (0:2*pi:2*pi*(p.nphase - 1))/p.nphase;else	diffph = 0;	p.nphase = 1;end% MAKE ALL THE FRAMESmymovie = cell(p.nphase,1);iframe = 0;thissf = 1./ltdeg2pix(1/p.sf,myscreen); % sf in cycles/pixfor iph = 1:p.nphase    iframe = iframe+1;    thisori = 0; % diffori(iori); stimulus will be rotated during presentation    thisphase = diffph(iph);    % make the stimulus aperture    angfreq = -2*pi*thissf*( cos(thisori).*xx + sin(thisori).*yy );    % introduce a phase correction for the offset of the window.    % phzcorr = 2.*pi.*thispos.*thissf; OBSOLETE    % EDITED BY MC AND AB 2006-03-20: sin TO cos    % movieimage = p.c * cos( phzcorr + thisphase + angfreq );    movieimage = p.c * cos(thisphase + angfreq);    mymovie{iframe} = uint8(round(( movieimage + 1 )*126 + 3));    % and at this point movieimage goes bet 3 and 255endif p.bprob > 0	ngrat = p.nori*p.nphase.*p.npos; % keep ngrat like it was because blank probability refers to to all possible combinations	nblnk = round(ngrat.*(1/p.bprob-1).^-1);    % make 1 frame for the blank stim    iframe = iframe+1;    movieimage = zeros(size(xx));    mymovie{iframe} = uint8(round((movieimage + 1)*126 + 3));    % and at this point movieimage contains gray (129)end% That's it for the framesStim.frames{1} = mymovie;% % MAKE ALL THE LUTSlinClut = [ [128 128 128]; [255 255 255]; [ 0 0 0]; round(linspace(0,255,253))'*[1 1 1] ];Stim.luts{1} = linClut;% The number of frames in the entire stimulusnframes = ceil(p.dur * myscreen.FrameRate);Stim.sequence.luts = ones(1,nframes);% The position of the stimulus% First: center the stim where the user wants itx1 = round(myscreen.Xmax/2) - round(p.barwdth/2);y1 = round(myscreen.Ymax/2) - round(p.barlgth/2);x2 = round(myscreen.Xmax/2) + round(p.barwdth/2);y2 = round(myscreen.Ymax/2) + round(p.barlgth/2);homePos = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);% Now: shift the stim relative to thatframePos = cell(p.nori,1);for iori = 1 : p.nori    framePos{iori} = zeros(p.npos,4);    for ipos = 1 : p.npos        shiftX = cos(diffori(iori)) * diffpos(ipos);        shiftY = sin(diffori(iori)) * diffpos(ipos);        framePos{iori}(ipos,:) = OffsetRect(homePos, shiftX, shiftY);    endend% The number of images that contain a gratingngrat = p.nori*p.nphase*p.npos+nblnk;% The sequence of frames (position and spatial phase)frameseq = zeros(1, nframes);% DEFINE THE RANDOM SEQUENCE OF THE FRAMES% Set the seed, and select the Matlab 4 rand num generatorrand('seed',p.seed);stimseq = min(ngrat ,ceil(rand(1,nframes)*ngrat)); % number of frames temporaryframeseq(stimseq > ngrat-nblnk) = length(mymovie); % blank framesnstimPerPhase = p.nori*p.npos;for iphase = 1 : p.nphase    frameseq(stimseq > (iphase-1)*nstimPerPhase & stimseq <= iphase*nstimPerPhase) = iphase;end% The sequence of orientations and positionsrand('seed',p.seed+10);oriIndex = ceil(rand(1,nframes)*p.nori);rand('seed',p.seed+20);posIndex = ceil(rand(1,nframes)*p.npos);% Interpolate these frames frameindex = floor(1:1/p.nfr:nframes);Stim.sequence.frames = frameseq(frameindex(1:nframes));Stim.ori = difforideg(oriIndex(frameindex(1:nframes)));for iframe = 1 : length(Stim.ori)    Stim.position(iframe,:) = framePos{oriIndex(frameindex(iframe))}(posIndex(frameindex(iframe)),:);endStim.offset = [p.x p.y];% The number of times you want to see the movie		Stim.nperiods = 1;Stim.globalAlpha = ones(1,nframes);Stim.srcRect = cell(1,nframes);%% The parameters of each stimulus imageiImage = 0; % unique combination of ori, pos, phaseiMovieFrame = 0; % unique frames computedfor iph = 1:p.nphase    iMovieFrame = iMovieFrame + 1;    for ipos = 1:p.npos        for iori = 1:p.nori            iImage = iImage+1;            NoisePars.ori(  iImage) = diffori(iori)/pi*180;            NoisePars.pos(  iImage) = diffpos(ipos); % SF in cpd            NoisePars.phase(iImage) = diffph(iph)/pi*180;            NoisePars.c(    iImage) = p.c;            NoisePars.sf(   iImage) = p.sf;            % images with different ori and pos share the same MovieFrame            NoisePars.iMovieFrame( iImage ) = iMovieFrame;        end    endendif p.bprob > 0	ngrat = p.nori*p.nphase.*p.npos;	nblnk = round(ngrat.*(1/p.bprob-1).^-1);    iMovieFrame = iMovieFrame + 1; % one MovieFrame for the blank stimulus    % the adaptor frames    for ibl = 1:nblnk        iImage = iImage+1;        NoisePars.ori(iImage) = NaN;        NoisePars.pos(iImage) = NaN;        NoisePars.phase(iImage) = NaN;        NoisePars.c(iImage) = 0;        NoisePars.sf(iImage) = NaN;        NoisePars.iMovieFrame( iImage ) = iMovieFrame;    endend%% Added by Matteo 30 Jan 2008% This is a hack to create a virtual "sequence of frames" to be used in% subsequent analyses in lieu of the usual Stim.sequence.framesdiffphdeg = diffph/pi*180;phaseIndex = Stim.sequence.frames;phaseIndex(phaseIndex > length(diffph) ) = NaN;NoisePars.VirtualSequence = zeros(nframes,1);for iframe = 1:nframes % frames refers to the physical monitor frames here    if Stim.sequence.frames(iframe)> length(diffph)        % it is a blank        NoisePars.VirtualSequence(iframe) = length(NoisePars.ori);    else        % it has to be one of these stimuli        NoisePars.VirtualSequence(iframe) = find( ...            round(NoisePars.ori) == round(difforideg(oriIndex(frameindex(iframe)))) & ...            NoisePars.pos ==    diffpos(posIndex(frameindex(iframe))) & ...            NoisePars.phase == diffphdeg(phaseIndex(iframe)) );    endend%% Laura's new code to get the screen images 14 Mar 2008% we only need this for the analyses, not when we run an experimentif ~isempty(Screen('Windows'))    returnend% minLeft = min(Stim.position(:,1));% maxRight = max(Stim.position(:,1)) + max(Stim.position(:,3));% FakeScreenWidth = maxRight - minLeft;% minBottom = min(Stim.position(:,2));% maxTop = max(Stim.position(:,2)) + max(Stim.position(:,4));% FakeScreenHeight = maxTop - minBottom;screens=Screen('Screens');[windowPointer]=Screen('OpenWindow', max(screens), 127, [0,0,myscreen.Xmax,myscreen.Ymax]);Screen('BlendFunction', windowPointer, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); % needed for alpha blendingiscreen = 0;iMovieFrame = 0;for iph = 1:p.nphase    iMovieFrame = iMovieFrame + 1;    for ipos = 1:p.npos        for iori = 1:p.nori            iscreen = iscreen + 1;            textureIndex = Screen('MakeTexture', windowPointer, Stim.frames{1}{iMovieFrame});            Screen('DrawTexture', windowPointer, textureIndex ,[], framePos{iori}(ipos,:), difforideg(iori));            Screen('Flip', windowPointer);            NoisePars.screen{iscreen} = imresize(rgb2gray(Screen('GetImage', windowPointer)), 0.2);            Screen('Close', textureIndex);        end    endendif p.bprob > 0    ngrat = p.nori*p.nphase.*p.npos;    nblnk = round(ngrat.*(1/p.bprob-1).^-1);    iMovieFrame = iMovieFrame + 1; % one MovieFrame for the blank stimulus    for iblnk = 1 : nblnk        iscreen = iscreen + 1;        textureIndex = Screen('MakeTexture', windowPointer, Stim.frames{1}{iMovieFrame});        Screen('DrawTexture', windowPointer, textureIndex ,[], framePos{iori}(ipos,:), difforideg(iori));        Screen('Flip', windowPointer);        NoisePars.screen{iscreen} = imresize(rgb2gray(Screen('GetImage', windowPointer)),0.2);        Screen('Close', textureIndex);    endendScreen('CloseAll');return%% -------------------------------------------------------------% Code to test the functionwhichScreen = 1;myscreen = ltScreenInitialize(whichScreen);myscreen.Dist = 57;% The parametersdur 		= 200; % sec*10c			= 50; % contrast in %barlgth		= 200; % diameter (deg/10).barwdth		= 20; % number of orientationssf			= 40; %spatial frequencies (sf/100)nori        = 8;   %number of orientationsnpos        = 8;   %number of positions of the barsnphase		= 2; % the number of spatial frequenciesseed		= 1; % the seed of random number generatornfr			= 20; % the number of interpolated framesbprob       = 50; % percent chance that the stimulus is blankpars = [dur c barlgth barwdth sf nori npos nphase seed nfr bprob];Stim = oglrandposLB(pars,myscreen);Stim = vsLoadTextures(myscreen, Stim);vsPlayStimulus(myscreen,Stim);ltClearStimulus(Stim,'nowarnings');