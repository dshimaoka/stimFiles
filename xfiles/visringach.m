function Stim =  visringach(pars,myscreen);% Stim =  visringach(pars,myscreen);%% code for visringach.x (6 oris, 4 phases, 1 adaptor)%% 2000-04 MC% ------ parse the pars (excuse the pun)xpars.dur 	= pars(1)/10; % duration.xpars.x		= ceil(ltdeg2pix(pars(04)/10,myscreen)); % Centre x (deg/10).xpars.y		= ceil(ltdeg2pix(pars(05)/10,myscreen)); % Centre y (deg/10).xpars.diam	= ceil(ltdeg2pix(pars(06)/10,myscreen)); % diameter (deg/10).seed = pars(7);aori = pars(8)* (pi/180); 	% orientation of adaptor;aprob = pars(9);			% prob of showing the adaptorSinPars = [];SinPars.Frequency 	= 1./ltdeg2pix(10/pars(2),myscreen); % sf in cycles/pixSinPars.Contrast 	= pars(3)/100; %  contrast. % ------ and into the relevant fields of MovieParsMoviePars.nx = xpars.diam; MoviePars.ny = xpars.diam;MoviePars.nframes = round(myscreen.FrameRate * xpars.dur); % frames/sec * sec % ------ other xpars to be keptdiam = xpars.diam; ctr.x = xpars.x;ctr.y = xpars.y;% ------ that's it, no more use for xparsclear xpars%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clear Stimdifforis = pi*[0:5]/6;diffphases = pi*[0:3]/2; % was 4noris = length(difforis);nphases = length(diffphases);% ---- make a grid of x and yx = 1-MoviePars.nx/2:MoviePars.nx/2;y = 1-MoviePars.ny/2:MoviePars.ny/2;[xx,yy]=meshgrid(x,y);window = ( xx.^2+yy.^2 < diam^2/4 ); % circular window% make the movie ------------------------------------------movie = cell(noris*nphases+1,1);iframe = 0;for iori = 1:noris	for iphase = 1:nphases		iframe = iframe+1;		thisori = difforis(iori);		thisphase = diffphases(iphase);		% the minus sign below is for consistency with the orientation of other stimuli		angfreq = 2*pi*SinPars.Frequency*(-cos(thisori).*xx-sin(thisori).*yy );		movieimage = SinPars.Contrast * sin(thisphase+angfreq);		movie{iframe} = uint8(round((movieimage.*window+1)*126 + 3)); 		% and at this point movieimage goes bet 3 and 255	endend% the blank frameiframe = iframe+1;movie{iframe} = uint8(round((0*movieimage.*window+1)*126 + 3)); % the frames of the adaptorthisori = aori;for iphase = 1:nphases	iframe = iframe+1;	thisphase = diffphases(iphase);	% the minus sign below is for consistency with the orientation of other stimuli	angfreq = 2*pi*SinPars.Frequency*(-cos(thisori).*xx-sin(thisori).*yy );	movieimage = SinPars.Contrast * sin(thisphase+angfreq);	movie{iframe} = uint8(round((movieimage.*window+1)*126 + 3)); 	% and at this point movieimage goes bet 3 and 255endStim.frames{1} = movie;Stim = ltMakeOffScreenWindows(myscreen,Stim,1);% define the look-up tables for this stimuluslinClut = [ [128 128 128]; [255 255 255]; [  1   1   1]; round(linspace(1,255,253))'*[1 1 1] ];Stim.luts{1} = linClut;Stim.sequence.luts = ones(1,MoviePars.nframes);% coordinates of center of stimulus with respect to the top left of the screenx = ctr.x + myscreen.Xmax/2;y = ctr.y + myscreen.Ymax/2;% coordinates of top left of stimulus with respect to the top left of the screenx = x - round(MoviePars.nx/2);y = y - round(MoviePars.ny/2);Stim.position(1,:) = [x,y,x+MoviePars.nx,y+MoviePars.ny];% define the RANDOM SEQUENCE FOR THE FRAMES rand('seed',seed); % sets the seed, and selects the Matlab 4 rand num generatorntests = noris*nphases + 1;Stim.sequence.frames = ceil(rand(1,MoviePars.nframes)*ntests);% select a portion of the frames for the adaptor.adaptframes = find(rand(1,MoviePars.nframes)<aprob/100);nadaptframes = length(adaptframes);Stim.sequence.frames(adaptframes) = ntests+ceil(rand(1,nadaptframes)*nphases);% define the number of times you want to see the movie		Stim.nperiods = 1;	