function Stim =  v1lut1grat(pars,myscreen);% Stim =  v1lut1grat(pars,myscreen);%% code for v1lut1grat.x% just like visdriftsin100, but % - can be CONTRAST MODULATED % - has a phase parameter%% Stim = v1lut1grat([dur tf sf100 c ori phase x y diam flicker], myscreen)%% to see something reasonable, try with pars = [20 20 100 50 30 0 0 0 30 1]%% 2004-02 Matteo Carandini% ------ parse the parsxpars.dur 	= pars(1)/10;  % = dur; % Stim. duration.xpars.tf	= pars(2)/10;  % = tf; % Temporal frequency.xpars.sf 	= pars(3)/100;  % = sf100; % Spatial frequency.xpars.c 	= pars(4)/100; % = c; % Stim. constrast. xpars.ori 	= pars(5)*(pi/180); % = ori; % Stim. orientation .xpars.phase = pars(6)*(pi/180); % spatial phasexpars.x		= ceil(ltdeg2pix(pars(7)/10,myscreen)); % Center x (deg/10).xpars.y		= ceil(ltdeg2pix(pars(8)/10,myscreen)); % Center y (deg/10).xpars.diam	= ceil(ltdeg2pix(pars(9)/10,myscreen)); % diameter (deg/10).xpars.flickerflag = pars(10);% ------ convert them into relevant fields in SinParsSinPars.width 			 = xpars.diam; SinPars.height			 = xpars.diam;SinPars.Contrast		 = xpars.c;SinPars.Orientation 	 = xpars.ori;	% radiansSinPars.SpatialFrequency = xpars.sf;	% Cycles/degreeSinPars.tFreq			 = xpars.tf;	% Hz % SinPars.outerRad 		 = round(xpars.diam/2); % pixels!SinPars.phase			 = xpars.phase;	% 0 is cosine phase, must be RADIANSif xpars.flickerflag	SinPars.direction		 = 0; % COUNTERPHASE GRATINGelse	SinPars.direction		 = 1; % DRIFTING GRATINGend% ------ other SinPars fields to be setSinPars.sqwv			 = 0;	% 0=sine, 1=squareSinPars.innerRad 		 = 0;	% pixels!% ------ other xpars to be keptctr.x = xpars.x;ctr.y = xpars.y;nframes = round(myscreen.FrameRate * xpars.dur);% ------ that's it, no more use for xparsclear xpars%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim.frames{1}{1} = ltMakeGratingFrame(SinPars,myscreen,'reserve3');Stim = ltMakeOffScreenWindows(myscreen,Stim,1);[Cluts, nCluts] = ltMakeGratingCluts(SinPars,myscreen,'reserve3');Stim.luts = cell(nCluts,1); % allocationfor ii = 1:nCluts	Stim.luts{ii} = squeeze(Cluts(ii,:,:)); % why???endStim.sequence.frames 	= ones(1,nframes); % this will stay like thatStim.sequence.luts 		= ones(1,nframes); % this will change, it is just an allocationfor ii = 0:nframes - 1	Stim.sequence.luts(ii+1) = mod(ii,nCluts) + 1;end%------- define position rectx1 = (round(myscreen.Xmax/2) - round(SinPars.width/2));y1 = (round(myscreen.Ymax/2) - round(SinPars.height/2));x2 = (round(myscreen.Xmax/2) + round(SinPars.width/2));y2 = (round(myscreen.Ymax/2) + round(SinPars.height/2));	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim.nperiods = 1;return%----------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);dur = 50;tf = 10;sf100 = 20;c = 100;ori = 45;phase = 0;x = 10;y = 0;diam = 300;flicker = 0Stim1 = vlutgrat([dur tf sf100 c ori phase x y diam flicker],myscreen);vsPlayStimulus(myscreen,Stim1,'norush');	ltClearStimulus(Stim1,'nowarnings'); SCREEN('CloseAll');	