function Stim =  vismradapt(pars,myscreen);% Stim =  vismradapt(pars,myscreen);%% code for vismradapt.x%% Stim = vismradapt([dur tf sf x y diam cadapt oriadapt ctest oritest ntests testdur blankdur revdur], myscreen)%% reasonable values are% pars = [270 40 10 0 0 80 75 90 20 0 3 10 10 5];%% 2001-05 David Ress + Matteo Carandini% ------ parse the pars (excuse the pun) -----------xpars.dur 	= pars(1)/10;  					% s, Stim. duration.xpars.tf	= pars(2)/10;  					% Hz, Temporal frequency.xpars.sf 	= pars(3)/10;  					% cpd, Spatial frequency.xpars.x		= ceil(ltdeg2pix(pars(4)/10,myscreen)); % Centre x (deg/10).xpars.y		= ceil(ltdeg2pix(pars(5)/10,myscreen)); % Centre y (deg/10).xpars.diam	= ceil(ltdeg2pix(pars(6)/10,myscreen)); % diameter (deg/10).xpars.cadapt 	= pars( 7)/100; 		% = c; pecent Stim. contrast. xpars.oriadapt 	= pars( 8) * (pi/180); 	% rad, Stim. orientation .xpars.ctest 	= pars( 9)/100; 		% = c; percent Stim. contrast. xpars.oritest 	= pars(10) * (pi/180); 	% rad, Stim. orientation .xpars.ntests	= pars(11); 			% number of test stimulixpars.testdur 	= pars(12)/10;  		% s, test Stim. duration.xpars.blankdur 	= pars(13)/10;  		% s, blank Stim. duration.xpars.revdur 	= pars(14)/10;  		% s, reversal interval.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% let's make the adaptorAdaptPars.x 				= xpars.diam; AdaptPars.y 				= xpars.diam;AdaptPars.Contrast		 	= xpars.cadapt;AdaptPars.Orientation 	 	= xpars.oriadapt;	% radiansAdaptPars.SpatialFrequency 	= xpars.sf;	% Cycles/degreeAdaptPars.tFreq			 	= xpars.tf;	% Hz % AdaptPars.outerRad 		 	= round(xpars.diam/2); % pixels!AdaptPars.innerRad 		 	= 0;	% pixels!AdaptPars.phase			 	= 0;	% 0 is cosine phase, must be RADIANSAdaptPars.sqwv			 	= 0;	% 0=sine, 1=squareStim.frames{1}{1} = ltMakeGratingFrame(AdaptPars,myscreen,'reserve3');[AdaptCluts, nAdaptCluts] = ltMakeGratingCluts(AdaptPars,myscreen,'reserve3');% to look at it:% imagesc(Stim.frames{1}{1},[0 255]); colormap gray%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% let's make the testTestPars.x 					= xpars.diam; TestPars.y 					= xpars.diam;TestPars.Contrast		 	= xpars.ctest;TestPars.Orientation 	 	= xpars.oritest;	% radiansTestPars.SpatialFrequency 	= xpars.sf;	% Cycles/degreeTestPars.tFreq			 	= xpars.tf;	% Hz % TestPars.outerRad 		 	= round(xpars.diam/2); % pixels!TestPars.innerRad 		 	= 0;	% pixels!TestPars.phase			 	= 0;	% 0 is cosine phase, must be RADIANSTestPars.sqwv			 	= 0;	% 0=sine, 1=squareStim.frames{1}{2} = ltMakeGratingFrame(TestPars,myscreen,'reserve3');[TestCluts, nTestCluts] = ltMakeGratingCluts(TestPars,myscreen,'reserve3');% to look at it:% imagesc(Stim.frames{1}{1},[0 255]); colormap gray; axis image%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim.luts = cell(nTestCluts+nAdaptCluts+1,1); % allocationfor ii = 1:nAdaptCluts	Stim.luts{ii} = squeeze(AdaptCluts(ii,:,:)); % Ress knows whyendfor ii = 1:nTestCluts	Stim.luts{ii+nAdaptCluts} = squeeze(TestCluts(ii,:,:)); % Ress knows whyendStim.luts{end} = [ 127 127 127; 253 253 253; 1 1 1; repmat(127,253,3)]; % Blank LUTBlankLut = length(Stim.luts);adaptdur = xpars.dur - xpars.ntests*(xpars.testdur+xpars.blankdur);nreversalframes = round(myscreen.FrameRate * xpars.revdur);% ------ make adaptSeqnadaptframes = round(myscreen.FrameRate * adaptdur);nPeriods = ceil(nreversalframes / nAdaptCluts);cycleSeq = 1:nAdaptCluts;adaptSeq1 = repmat(cycleSeq, 1, nPeriods);adaptSeq1 = adaptSeq1(1:nreversalframes);adaptSeqR = [adaptSeq1, adaptSeq1([ end-1:-1:2]) ];nAdapt1 = length(adaptSeqR);nReversals = ceil(nadaptframes / nAdapt1);adaptSeq = repmat(adaptSeqR, 1, nReversals);adaptSeq = adaptSeq(1:nadaptframes);% ------ make blankSeqnblankframes = round(myscreen.FrameRate * xpars.blankdur);blankSeq = repmat(BlankLut,1,nblankframes);% ------ make testSeqntestframes = round(myscreen.FrameRate * xpars.testdur);nPeriods = ceil(nreversalframes / nTestCluts);cycleSeq = 1:nTestCluts;testSeq1 = repmat(cycleSeq, 1, nPeriods);testSeq1 = testSeq1(1:nreversalframes);testSeqR = [testSeq1, testSeq1([ end-1:-1:2]) ];nTest1 = length(testSeqR);nReversals = ceil(ntestframes / nTest1);testSeq = repmat(testSeqR, 1, nReversals);testSeq = testSeq(1:ntestframes) + nAdaptCluts;%-------- put them all together ---------Stim.sequence.luts = adaptSeq;for itest = 1:xpars.ntests	Stim.sequence.luts = [ Stim.sequence.luts blankSeq testSeq ];endnframes = length(Stim.sequence.luts);Stim.sequence.frames = ones(1,nframes);Stim.sequence.frames(nadaptframes+3:end) = 2; % probably because of a bug, we need 3 rather than 1Stim = ltMakeOffScreenWindows(myscreen,Stim,1);%------- define position rectctr.x = xpars.x;ctr.y = xpars.y;x1 = (round(myscreen.Xmax/2) - AdaptPars.x/2);y1 = (round(myscreen.Ymax/2) - AdaptPars.y/2);x2 = (round(myscreen.Xmax/2) + AdaptPars.x/2);y2 = (round(myscreen.Ymax/2) + AdaptPars.y/2);	Stim.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr.x,ctr.y);Stim.nperiods = 1;return%----------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 57;ltLoadCalibration(myscreen,3);Stim = vismradapt([270 40 10 0 0 80 75 90 20 0 3 10 10 5], myscreen)vsPlayStimulus(myscreen,Stim,'norush');	vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');	