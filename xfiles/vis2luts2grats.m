function Stim =  vis2luts2grats(pars,myscreen)% Stim =  vis2luts2grats(pars,myscreen)%% code for vis2luts2grats.x%% 2000-01 TCB and MC % 2000-04 MC cleaned up a lot. Now it returns Stim, and does not play it.% 2001-01 modified so it takes 2 phases and has inner diams%% SEE CODE AT THE END OF THE FUNCTION TO TEST % pars = [ 20 40 10 0 50 90 0 0 0 40 30 10 0 50 45 20 -20 20 60 ]% ------ parse the pars (excuse the pun)dur 	= pars(1)/10 /2; %= dur; % Stim. durationSinPars = [];SinPars(1).tFreq	 			= pars(2)/10 * 2; 	SinPars(1).SpatialFrequency  	= pars(3)/10; 		SinPars(1).phase  				= pars(4)* (pi/180); 		SinPars(1).Contrast 	 		= pars(5)/100 * 2; SinPars(1).Orientation 			= pars(6) * (pi/180); ctr(1).x	 			=  round(ltdeg2pix(pars (7)/10,myscreen)); % Centre x (deg/10).ctr(1).y				=  round(ltdeg2pix(pars( 8)/10,myscreen)); % Centre y (deg/10).SinPars(1).innerRad			=  ceil(ltdeg2pix(pars( 9)/10,myscreen)/2); % inner diameter (deg/10).SinPars(1).outerRad			= floor(ltdeg2pix(pars(10)/10,myscreen)/2); % outer diameter (deg/10).SinPars(1).sqwv	= 0;	% 0=sine, 1=squareSinPars(2).tFreq	 			= pars(11)/10 * 2; 	SinPars(2).SpatialFrequency  	= pars(12)/10; 		SinPars(2).phase  				= pars(13)* (pi/180); 		SinPars(2).Contrast 	 		= pars(14)/100 * 2; SinPars(2).Orientation 			= pars(15) * (pi/180); ctr(2).x	 			=  round(ltdeg2pix(pars(16)/10,myscreen)); % Centre x (deg/10).ctr(2).y				=  round(ltdeg2pix(pars(17)/10,myscreen)); % Centre y (deg/10).SinPars(2).innerRad			=  ceil(ltdeg2pix(pars(18)/10,myscreen)/2); % inner diameter (deg/10).SinPars(2).outerRad			= floor(ltdeg2pix(pars(19)/10,myscreen)/2); % outer diameter (deg/10).SinPars(2).sqwv	= 0;	% 0=sine, 1=squarenframes = round(myscreen.FrameRate * dur);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim = cell(2,1);for ipatch = 1:2		Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);		[Cluts, nCluts] = ltMakeGratingCluts(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch}.luts = cell(nCluts,1); % allocation	for iClut = 1:nCluts		Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); 	end	Stim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initialization	Stim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation only	for iframe = 0:nframes - 1		Stim{ipatch}.sequence.luts(iframe+1) = mod(iframe,nCluts) + 1;	end	%------- define position rect	x1 = (round(myscreen.Xmax/2) - SinPars(ipatch).outerRad);	y1 = (round(myscreen.Ymax/2) - SinPars(ipatch).outerRad);	x2 = (round(myscreen.Xmax/2) + SinPars(ipatch).outerRad);	y2 = (round(myscreen.Ymax/2) + SinPars(ipatch).outerRad);		Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr(ipatch).x,ctr(ipatch).y);		Stim{ipatch}.nperiods = 1;	endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 65;ltLoadCalibration(myscreen,3);Stim = vis2luts2grats([ 20 20 10 0 50 45 -20 0 20 40 30 10 0 50 45 -40 100  20 60 ],myscreen);vsPlayStimulus(myscreen,Stim{1});	vsPlayStimulus(myscreen,Stim{2});	vsPlayStimulus(myscreen,Stim{1},Stim{2});	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');