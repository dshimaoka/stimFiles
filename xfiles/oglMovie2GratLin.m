function Stim = oglMovie2GratLin(pars,myscreen)% Two gratings a` la OpenGL, minimal use of textures, smart summation% % DO NOT USE THIS FUNCTION!!! IT IS BUGGY WHEN IT COMES TO DRIFTING GRATINGS!!!% (note added by MC in February 2010)%% Stim =  oglMovie2GratLin(pars,myscreen)% where pars is% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb2 x2 y2 flick2 sqwv2 duty2 shape2 ]%% sqwv = 1 for square waves, 0 for sin waves duty is the duty cycle in% percent (normal is 100) shape determines whether the window is an annulus% (shape = 0) or a rectangle (shape = 1) dima and dimb are inner and outer% diameter (for annuli) or dimensions x and y (for rectangles)%% based on oglMovie2Grat but smart summation% based on vmovie2gratinterok.x%% based on 2004-11 Matteo Carandini% LB 2008-03-06 added some of the ogl capabilities (orientation)% LB enabled proper blending for linear superposition% 2010-02-03 MC added flag FlagMinusOneToOne to stim structure%% % COMMENTED OUT BY MC 2010-02-01 AND MOVED TO VS% Screen('BlendFunction', myscreen.windowPtr, GL_SRC_ALPHA, GL_ONE);% Durationdur 	= pars(1)/10; %= dur; % Stim. durationipar = 1;for igrat = 1:2	sinpars(igrat).tfreq	 	= pars(ipar+1)/10; 		sinpars(igrat).sfreq  		= pars(ipar+2)/100; 			sinpars(igrat).tempphase  	= pars(ipar+3) * (pi/180); 			sinpars(igrat).spatphase  	= pars(ipar+4) * (pi/180); 			sinpars(igrat).contrast 	= pars(ipar+5)/100; 	sinpars(igrat).orientation 	= pars(ipar+6);% * (pi/180); orientation is in deg for ogl	sinpars(igrat).dima			= ceil (ltdeg2pix(pars(ipar+7)/10,myscreen)); % inner diameter (deg/10).	sinpars(igrat).dimb			= floor(ltdeg2pix(pars(ipar+8)/10,myscreen)); % outer diameter (deg/10).	sinpars(igrat).x	 		= ltdeg2pix(pars(ipar+ 9)/10,myscreen); % Centre x (deg/10).	sinpars(igrat).y		 	= ltdeg2pix(pars(ipar+10)/10,myscreen); % Centre y (deg/10).	sinpars(igrat).flicker 		= pars(ipar+11);	sinpars(igrat).sqwv 		= pars(ipar+12);	sinpars(igrat).duty  		= pars(ipar+13)/100;	sinpars(igrat).shape  		= pars(ipar+14); % 0 = circle; 1 = rect	ipar = 15;end% added by MC 2010-02-08:if ~all([sinpars(:).flicker])    error('oglMovie2GratLin CANNOT BE USED for drifting gratings, IT IS BUGGY!!!');endnframes = round(myscreen.FrameRate * dur); 	for igrat = 1:2		t = 0.001; % threshold	% cos( d/100*pi/2 )^n = t	if sinpars(igrat).duty<1		beta = log(t)/log(cos( sinpars(igrat).duty*pi/2 ));	else		beta = 1;	end		% Spatial frequency in cycles/pixel	PixPerCycle = ltdeg2pix(1/sinpars(igrat).sfreq,myscreen);	sinpars(igrat).frequency = 1/PixPerCycle; % sf in cycles/pix		switch sinpars(igrat).shape	case 0 		% it is an annulus		maxrad = max(1, sinpars(igrat).dimb/2);		nx = ceil(2*maxrad);		ny = ceil(2*maxrad);		case 1		% it is a rectangle		nx = max(1,sinpars(igrat).dima);		ny = max(1,sinpars(igrat).dimb);	end		% Make a grid of x and y	[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);		% The spatial phase of the stimulus	% the minus sign below is for consistency with the orientation of other stimuli    ori = 0; % LB 080306: sinpars(igrat).orientation will be used later	angfreq{igrat} = -2*pi* sinpars(igrat).frequency * (...		cos(ori).*xx + ...		sin(ori).*yy ) + sinpars(igrat).spatphase;	% in radians		switch sinpars(igrat).shape	case 0 		% an annular window		dd = sqrt(xx.^2+yy.^2);		win{igrat} = double(dd >= sinpars(igrat).dima/2 & dd <= sinpars(igrat).dimb/2);	case 1		% no window is needed to make a rectangle		win{igrat} = 1;	end		% The temporal phase of the response		periods(igrat) = round(myscreen.FrameRate / sinpars(igrat).tfreq);	tphase{igrat} = 2*pi*[0:(periods(igrat)-1)]/periods(igrat) + sinpars(igrat).tempphase;	fprintf(1,'Frequency %d is %2.2f rather than %2.0f Hz\n', ...		igrat, myscreen.FrameRate/periods(igrat) /2, sinpars(igrat).tfreq /2);			% Make movies	fprintf(1,' Frames for grating %d...', igrat);	if sinpars(igrat).flicker		%contrast = sinpars(igrat).contrast * sin(tphase{igrat});		contrast = 1 * sin(tphase{igrat}); % contrast will be set by alpha blending			spatialstim = sin(angfreq{igrat});			spatialstim = sign(spatialstim).*abs(spatialstim).^beta;		if sinpars(igrat).sqwv			spatialstim = (spatialstim>0.01)-(spatialstim<-0.01);		end		for iframe = 1:periods(igrat)			grat{igrat,iframe} = contrast(iframe) .* spatialstim .* win{igrat};		end			else		for iframe = 1:periods(igrat)			spatialstim = sin( angfreq{igrat} + tphase{igrat}(iframe));			spatialstim = sign(spatialstim).*abs(spatialstim).^beta;			if sinpars(igrat).sqwv				spatialstim = (spatialstim>0.01)-(spatialstim<-0.01);			end				grat{igrat,iframe} = sinpars(igrat).contrast * spatialstim  .* win{igrat};		end	end	for iframe = 1:periods(igrat)		Stim{igrat}.frames{1}{iframe} = grat{igrat,iframe}; % leave the stim between -1 and 1	end		% Make the lookup table	Stim{igrat}.luts{1} = repmat([128 255 0 1:253]',1,3);		% Make sequence	Stim{igrat}.sequence.frames = 1+mod(1:nframes,periods(igrat));	Stim{igrat}.sequence.luts = ones(1,nframes);		fprintf(1,'Putting them offscreen...');	Stim{igrat} = ltMakeOffScreenWindows(myscreen,Stim{igrat},1);		fprintf(1,'done\n');		% The position vector	x = round(sinpars(igrat).x + myscreen.Xmax/2 - nx/2);	y = round(sinpars(igrat).y + myscreen.Ymax/2 - ny/2);	Stim{igrat}.position(1,:) = [x y x+nx y+ny];		Stim{igrat}.nperiods = 1;	    % Laura 080306    Stim{igrat}.ori = sinpars(igrat).orientation*ones(1,nframes);    Stim{igrat}.globalAlpha = sinpars(igrat).contrast*ones(1,nframes);    Stim{igrat}.srcRect = cell(1,nframes);    % Matteo 2010-02-03    % from now on this flag will tell the rest of the code how to do alpha    % blending...    Stim{igrat}.FlagMinusOneToOne = 1;    endreturn%% TO TEST IT:% [  dur ...%    tf1 sf1 tph1 sph1 c1 ori1 dima1 dimb1 x1 y1 flick1 sqwv1 duty1 shape1...%    tf2 sf2 tph2 sph2 c2 ori2 dima2 dimb x2 y2 flick2 sqwv2 duty2 shape2]myscreen = ltScreenInitialize(2,1);		myscreen.Dist = 57;ltLoadCalibration(myscreen);% ltClearStimulus(Stim,'nowarnings'); % this looks WRONGpars1 = [ 20 ...    30 5 0 0 100 80 0 200 0 0 0 0 100 0 ...    30 5 0 0   0 80 0 200 0 0 0 0 100 0 ];% this looks RIGHTpars2 = [ 20 ...    30 5 0 0 50 80 0 200 0 0 0 0 100 0 ...    30 5 0 0 50 80 0 200 0 0 0 0 100 0 ];Stim1 = oglMovie2GratLin(pars1,myscreen);Stim2 = oglMovie2GratLin(pars2,myscreen);Stim1 = vsLoadTextures(myscreen, Stim1);Stim2 = vsLoadTextures(myscreen, Stim2);m = vsPlayStimulus(myscreen,Stim1,[],[],[], 1);m = vsPlayStimulus(myscreen,Stim2,[],[],[], 1);ltClearStimulus(Stim,'nowarnings'); ltClearLoadedTextures;Screen('CloseAll');