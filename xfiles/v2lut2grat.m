function Stim =  v2lut2grat(pars,myscreen)% Stim =  v2lut2grat(pars,myscreen)%% code for v2lut2grat.x%% Just like vis2luts2grats100 but can do counterphase%% Parameters are % [ dur ...%	tf1 sf1 ph1 c1 ori1 x1 y1 idiam1 odiam1 flicker1%	tf2 sf2 ph2 c2 ori2 x2 y2 idiam2 odiam2 flicker2 ]%% SEE CODE AT THE END OF THE FUNCTION TO TEST % pars = [ 20    40 10 0 50 90 0 0 0 40 0    30 10 0 50 45 20 -20 20 60 1 ]dur 	= pars(1)/10 /2; %= dur; % Stim. durationSinPars = [];SinPars(1).tFreq	 			= pars(2)/10 * 2; 	SinPars(1).SpatialFrequency  	= pars(3)/100; 		SinPars(1).phase  				= pars(4)* (pi/180); 		SinPars(1).Contrast 	 		= pars(5)/100 * 2; SinPars(1).Orientation 			= pars(6) * (pi/180); ctr(1).x	 			=  round(ltdeg2pix(pars (7)/10,myscreen)); % Centre x (deg/10).ctr(1).y				=  round(ltdeg2pix(pars( 8)/10,myscreen)); % Centre y (deg/10).SinPars(1).innerRad			=  ceil(ltdeg2pix(pars( 9)/10,myscreen)/2); % inner diameter (deg/10).SinPars(1).outerRad			= floor(ltdeg2pix(pars(10)/10,myscreen)/2); % outer diameter (deg/10).SinPars(1).sqwv	= 0;	% 0=sine, 1=squareSinPars(1).direction = (pars(11)==0);SinPars(2).tFreq	 			= pars(12)/10 * 2; 	SinPars(2).SpatialFrequency  	= pars(13)/100; 		SinPars(2).phase  				= pars(14)* (pi/180); 		SinPars(2).Contrast 	 		= pars(15)/100 * 2; SinPars(2).Orientation 			= pars(16) * (pi/180); ctr(2).x	 			=  round(ltdeg2pix(pars(17)/10,myscreen)); % Centre x (deg/10).ctr(2).y				=  round(ltdeg2pix(pars(18)/10,myscreen)); % Centre y (deg/10).SinPars(2).innerRad			=  ceil(ltdeg2pix(pars(19)/10,myscreen)/2); % inner diameter (deg/10).SinPars(2).outerRad			= floor(ltdeg2pix(pars(20)/10,myscreen)/2); % outer diameter (deg/10).SinPars(2).sqwv	= 0;	% 0=sine, 1=squareSinPars(2).direction = (pars(21)==0);nframes = round(myscreen.FrameRate * dur);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Stim = cell(2,1);for ipatch = 1:2		Stim{ipatch}.frames{1}{1} = ltMakeGratingFrame(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch} = ltMakeOffScreenWindows(myscreen,Stim{ipatch},1);		[Cluts, nCluts] = ltMakeGratingCluts(SinPars(ipatch),myscreen,'reserve3');		Stim{ipatch}.luts = cell(nCluts,1); % allocation	for iClut = 1:nCluts		Stim{ipatch}.luts{iClut} = squeeze(Cluts(iClut,:,:)); 	end 	Stim{ipatch}.sequence.frames 	= ones(1,nframes); % for allocation and initialization	Stim{ipatch}.sequence.luts 		= ones(1,nframes); % for allocation only	for iframe = 0:nframes - 1		Stim{ipatch}.sequence.luts(iframe+1) = mod(iframe,nCluts) + 1;	end	%------- define position rect	x1 = (round(myscreen.Xmax/2) - SinPars(ipatch).outerRad);	y1 = (round(myscreen.Ymax/2) - SinPars(ipatch).outerRad);	x2 = (round(myscreen.Xmax/2) + SinPars(ipatch).outerRad);	y2 = (round(myscreen.Ymax/2) + SinPars(ipatch).outerRad);		Stim{ipatch}.position(1,:) = OffsetRect([ x1 y1 x2 y2 ],ctr(ipatch).x,ctr(ipatch).y);		Stim{ipatch}.nperiods = 1;	endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:myscreen = ltScreenInitialize(1);		myscreen.Dist = 65;ltLoadCalibration(myscreen,3);pars = [ 40    10 10 0 50 90 0 0 0 40 0    5 10 0 50 45 -100 -100 -100 60 1 ]Stim = v2lut2grat(pars,myscreen);vsPlayStimulus(myscreen,Stim{1},'norush');	vsPlayStimulus(myscreen,Stim{2});	vsPlayStimulus(myscreen,Stim);	ltClearStimulus(Stim,'nowarnings'); SCREEN('CloseAll');