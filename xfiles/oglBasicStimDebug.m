function [oglStim] = oglBasicStimDebug(pars,myscreen)%% [oglStim] =  oglBasicStimDebug(pars,myscreen);%% Parameters are :% [dur c]%% 2010-06 ND created based on oglRandpos.m with some help from oglTwoGratings.m% ------ parse the parametersp.dur 		  = pars(1)/10; % duration (converted from sec*10)p.c			  = pars(2)/100; % contrast (converted from %)p.barwdth     = ceil(ltdeg2pix(5,myscreen)); % width of bar (converted from 5 degrees to pixels).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fundamental fieldsoglStim = oglStimNew(); % preallocate so you have correct order of parametersoglStim.Generation = 3; % 3rd gen (1 = pre-OpenGL, 2 = partial OpenGL, 3 = fuller OpenGL)oglStim.Type = 'oglBasicStimDebug';oglStim.Pars = pars;oglStim.FlagMinusOneToOne = true;oglStim.TextureParameters = 1:length(pars);% The number of frames in the entire stimulusnframes = ceil(p.dur * myscreen.FrameRate);%%% Make a grid of x and ynx = p.barwdth; % width of the barp.barlgth = round(sqrt(myscreen.Ymax^2 + myscreen.Xmax^2)); % diagonal of screen (max length conceivable in pixels)ny = p.barlgth;[xx,yy] = meshgrid(1-nx/2:nx/2,1-ny/2:ny/2);% home positions% center of screen. could be a parameter in future if want to limit portion% of screen on which you show stimuli so that you don't waste a lot of% stimuli. in that case would have to change the automatic calculation of% stimulus position and numberp.x = 0; p.y = 0; % in pixels% Compute the orientations of the stimulidori = 0;p.nori = 1;p.baseori = 0;diffori = zeros(1,p.nori);diffori(1) = 0 + pi*(p.baseori)/180; % base orientation after converting to radiansfor iori = 2:p.nori	diffori(iori) = diffori(iori-1) + dori;enddiffori = mod(diffori,2*pi); % these are the orientations used, expressed as angles in radiansdifforideg = diffori * 180 / pi; % convert to deg% first make it such that fills space for screenp.npos = ceil(myscreen.Xmax/p.barwdth);dpos = round((myscreen.Xmax-p.barwdth)./(p.npos-1));diffpos = dpos.*linspace(-(p.npos-1)./2, (p.npos-1)./2,p.npos);% now chuck out every other onediffpos(2:2:end) = [];p.npos = length(diffpos);%  the number of different texturesp.ntexts = 4;% make contrast vectorconts = linspace(-p.c,p.c,p.ntexts+1);conts(p.ntexts/2+1)=[];fprintf(1,'Contrasts are [%1.2f, %1.2f, %1.2f, %1.2f]\n',conts);% MAKE ALL THE FRAMESmymovie = cell(p.ntexts,1);% first make the stimuli frames at the desired stimulus contrastthisphase = 0;thisori = 0; % stimulus will be rotated during presentationthissf = 0;% thissf = 1./ltdeg2pix(1/p.sf,myscreen); % sf in cycles/pixfor itext = 1:p.ntexts    thiscont = conts(itext);    % make the stimulus aperture    angfreq = -2*pi*thissf*( cos(thisori).*xx + sin(thisori).*yy );    movieimage = thiscont * cos(thisphase + angfreq);    mymovie{itext} = uint8(round(( movieimage + 1 )*126 + 2));    % and at this point movieimage goes bet 2 and 254    mymovie{itext} = movieimage;    % and at this point movieimage goes bet -1 and 1end% That's it for the framesoglStim.frames{1} = mymovie;% % MAKE ALL THE LUTSlinClut = [ [128 128 128]; [255 255 255]; [ 0 0 0]; round(linspace(0,255,253))'*[1 1 1] ];for itext = 1:p.ntexts    oglStim.luts{itext,1} = linClut;end% The number of frames in the entire stimulusnframes = ceil(p.dur * myscreen.FrameRate);oglStim.sequence.luts = repmat(1:p.ntexts,1,nframes)';% The position of the stimulus% First: center the stim where the user wants itx1 = round(myscreen.Xmax/2) - round(p.barwdth/2);y1 = round(myscreen.Ymax/2) - round(p.barlgth/2);x2 = round(myscreen.Xmax/2) + round(p.barwdth/2);y2 = round(myscreen.Ymax/2) + round(p.barlgth/2);homePos = OffsetRect([ x1 y1 x2 y2 ],p.x,p.y);% Now: shift the stim relative to thatframePos = cell(p.nori,1);for iori = 1 : p.nori    framePos{iori} = zeros(p.npos,4);    for ipos = 1 : p.npos        shiftX = cos(diffori(iori)) * diffpos(ipos);        shiftY = sin(diffori(iori)) * diffpos(ipos);        framePos{iori}(ipos,:) = OffsetRect(homePos, shiftX, shiftY);    endendoglStim.position = framePos{1};oglStim.offset = [p.x p.y];% The sequence of frames (position and spatial phase)frameseq = repmat((1:p.ntexts),1,nframes);% The sequence of orientations and positionsoriIndex = p.nori*ones(p.ntexts,nframes);posIndex = frameseq;% Interpolate these frames oglStim.positionIndex = posIndex(:);oglStim.sequence.frames = frameseq(:);oglStim.ori = difforideg(oriIndex);% The number of times you want to see the movie		oglStim.nperiods = 1;oglStim.globalAlpha = ones(p.ntexts,nframes);oglStim.srcRect = cell(p.ntexts*nframes,1);return%% -------------------------------------------------------------% Code to test the functionwhichScreen = 2;myscreen = ltScreenInitialize(whichScreen);myscreen.Dist = 57;% myscreen = ScreenLogLoad('F100617',1,2,'stim');%%% The parametersdur 		= 50; % sec*10c			= 60; % contrast in %pars_basicstimdebug = [dur c];Stim_debug = oglStimMake('oglBasicStimDebug',pars_basicstimdebug, myscreen);oglStimPlay(myscreen,Stim_debug);%%ltClearStimulus(Stim,'nowarnings');Screen('CloseAll');