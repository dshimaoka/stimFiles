function Stim = oglFlickDrift(pars,myscreen)% Code for flickDrift.x% % Stim =  oglFlickDrift(pars,myscreen)% Computes a drifting stimuli that is contrast modulated, given%   stimulus parameters PARS and screen parameter MYSCREEN%   PARS = [ dur tf sf c ori durOn durOff endBlank]%%   uses "aperture" trick (see DriftDemo2.m)%   LB 10-16-07%% 2008-01 LB changed Stim.ori to be a vector of size nframes instead of a scalar to be compatible with a new usage in vsPlayStimulus% 2008-01 LB changed Stim.srcRect to be a cell to be compatible with a new usage in vsPlayStimulus% 2008-01 LB changed Stim.position to be a matrix with nframesx4 entries% 2008-02 LB renamed it oglFlickDrift, and adjusted the parameter sf to match% those of other stimuli used in the lab. Also adjusted xoffset to match% orientation of other stimuli used in the lab% Parse the input parametersdur                     = pars(1)/10; % duration in ssinpars.tfreq           = pars(2)/10; % temporal freq cyc/s	sinpars.sfreq           = pars(3)/100; % spatial freq cyc/deg		sinpars.contrast        = pars(4)/100; % contrast of the gratingsinpars.orientation 	= 0; % supplied ori (pars(5)) is used in vsPlayStimulus to rotate the 0 deg stimulussinpars.dim  			= ceil(sqrt(myscreen.Xmax^2 + myscreen.Ymax^2)); % max size: screen diagonalsinpars.x               = ltdeg2pix(0,myscreen); % Centre xsinpars.y               = ltdeg2pix(0,myscreen); % Centre ysinpars.durOn           = round(myscreen.FrameRate*pars(6)/10);sinpars.durOff          = round(myscreen.FrameRate*pars(7)/10);sinpars.durEndblank     = round(myscreen.FrameRate*pars(8)/10); % blank screen at the endmotionDur = round(myscreen.FrameRate * dur);nframes = motionDur + sinpars.durEndblank;% half the size of the aperturetexsize = 0.5*sinpars.dim;% Spatial frequency in cycles/pixelPixPerCycle = ltdeg2pix(1/sinpars.sfreq,myscreen);sinpars.frequency = 1/PixPerCycle; % sf in cycles/pixPixPerCycle=ceil(PixPerCycle);  % pixels/cyclevisiblesize=2*texsize+1;% Create one single static grating image: grid of x and y% we need to add PixPerCycle to allow for moving the aperture (see mod% operations in l. 68 & 69% changed by MC in March 2011 against all rules, to save memory:% [x,y]=meshgrid(-texsize:texsize + PixPerCycle, -texsize:texsize + PixPerCycle);[x,y]=meshgrid(-texsize:texsize + PixPerCycle, PixPerCycle); % this exploits a neat trick in PsychToolbox (the texture can be 1D) and% gets replicated% the gratingangfreq = 2*pi* sinpars.frequency * (...     cos(sinpars.orientation).*x + ...     sin(sinpars.orientation).*y );spatialstim = sinpars.contrast * sin(angfreq);grat = {spatialstim};Stim.frames{1}{1} = uint8( grat{1}*126 + 129 );% Query duration of monitor refresh interval:ifi=Screen('GetFlipInterval', myscreen.windowPtr);waitframes = 1;waitduration = waitframes * ifi;% Translate requested speed of the grating (in cycles per second)% into a shift value in "pixels per frame", assuming given% waitduration: This is the amount of pixels to shift our "aperture" at% each redraw:shiftperframe= sinpars.tfreq * PixPerCycle * waitduration;%xshift = cos(sinpars.orientation)*shiftperframe;%yshift = sin(sinpars.orientation)*shiftperframe;for iframe = 1 : nframes % add some dummy frames in case we need a blank stim at the end for intrinsic    xoffset = mod(iframe*shiftperframe,PixPerCycle);    % LB 22-Feb-08: changed xoffset to -xoffset to match    % the orientations of the other stim used in the lab    Stim.srcRect{iframe} =[-xoffset 0 -xoffset + visiblesize visiblesize];    %xoffset = mod(iframe*xshift, PixPerCycle);    %yoffset = mod(iframe*yshift, PixPerCycle);    %Stim.srcRect(iframe,:) = [xoffset yoffset xoffset+visiblesize yoffset+visiblesize];end% Make the lookup tableStim.luts{1} = repmat([128 255 0 1:253]',1,3);% Make sequenceStim.sequence.frames = ones(1,nframes);Stim.sequence.luts = ones(1,nframes);fprintf(1,'done\n');% Definition of the drawn rectangle on the screen:dstRect=[0 0 visiblesize visiblesize];dstRect=CenterRect(dstRect, myscreen.ScreenRect);% The position vectorfor iframe = 1 : nframes    Stim.position(iframe,:) = dstRect;endStim.ori = pars(5)*ones(1,nframes);Stim.nperiods = 1;%Stim.globalAlpha(1:nframes) = 1;% % The alpha-blending vector (applies to the whole texture)blending = [zeros(1,sinpars.durOff) ones(1,sinpars.durOn)];nextra = mod(motionDur, length(blending));nblends = (motionDur - nextra) / length(blending);Stim.globalAlpha = repmat(blending, 1, nblends);Stim.globalAlpha(length(Stim.globalAlpha)+1:length(Stim.globalAlpha)+nextra) = blending(1:nextra);if sinpars.durEndblank > 0    Stim.globalAlpha(length(Stim.globalAlpha)+1:length(Stim.globalAlpha)+sinpars.durEndblank) = 0;endreturn%--------------------------------------------------------------------------------------------% TO TEST IT:%    PARS = [ dur tf sf c ori da x y durOn durOff endBlank]whichScreen = 1;myscreen = ltScreenInitialize(whichScreen);myscreen.Dist = 57;Stim = [];dur = 90;tf = 400; % tf = tf/100sf = 15; % sf = sf/100c = 100;ori = 225;durOn = 3;durOff = 3;endBlank = 0;pars = [ dur tf sf c ori durOn durOff endBlank];if ~isempty(Stim)    ltClearStimulus(Stim,'nowarnings'); endStim = flickDrift(pars,myscreen);Stim = vsLoadTextures(myscreen, Stim);vsPlayStimulus(myscreen,Stim);		ltClearStimulus(Stim,'nowarnings'); Screen('CloseAll');